<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>字跑大师</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a12;
            font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
            touch-action: none;
            user-select: none
        }

        #wrap {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative
        }

        canvas {
            display: block;
            image-rendering: pixelated
        }

        #hud {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            color: #fff;
            z-index: 10
        }

        #hud .row {
            display: flex;
            justify-content: space-between;
            padding: 6px 12px;
            font-size: 13px;
            opacity: .85
        }

        #hud .task {
            display: none
        }

        #hud .hearts {
            font-size: 18px;
            letter-spacing: 2px
        }

        #hud .score {
            font-size: 14px;
            color: #ffd700
        }

        #hud .timer {
            font-size: 14px;
            color: #ff6b6b
        }

        #hud .level {
            font-size: 12px;
            color: #aaa
        }

        #hud .combo {
            position: absolute;
            top: 350px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: #ff0;
            text-shadow: 0 0 8px rgba(255, 255, 0, .5);
            opacity: 0;
            transition: opacity .3s, transform .3s;
            white-space: nowrap;
            pointer-events: none;
        }

        #hud .combo.fade-out {
            opacity: 0 !important;
            transform: translateX(-50%) translateY(-30px);
        }

        #start-screen {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at 50% 40%, #1a1a2e 0%, #0a0a12 100%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity .6s
        }

        #start-screen h1 {
            font-size: 48px;
            color: #00ffcc;
            text-shadow: 0 0 30px rgba(0, 255, 204, .4);
            margin-bottom: 8px;
            letter-spacing: 6px
        }

        #start-screen .sub {
            color: #888;
            font-size: 14px;
            margin-bottom: 40px
        }

        #start-screen button {
            padding: 16px 56px;
            font-size: 20px;
            background: linear-gradient(135deg, #00ffcc, #00cc99);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            color: #003d33;
            box-shadow: 0 0 40px rgba(0, 255, 204, .3);
            transition: transform .2s, box-shadow .2s
        }

        #start-screen button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 60px rgba(0, 255, 204, .5)
        }


        #game-over {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .85);
            z-index: 80;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff
        }

        #game-over h2 {
            font-size: 36px;
            color: #ff6b6b;
            margin-bottom: 16px
        }

        #game-over .stats {
            font-size: 16px;
            line-height: 2;
            text-align: center;
            margin-bottom: 24px
        }

        #game-over button {
            padding: 14px 48px;
            font-size: 18px;
            background: #00ffcc;
            color: #003d33;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold
        }

        #level-clear {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .8);
            z-index: 80;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff
        }

        #level-clear h2 {
            font-size: 32px;
            color: #00ffcc;
            margin-bottom: 12px
        }

        #level-clear .info {
            font-size: 16px;
            line-height: 2;
            text-align: center;
            margin-bottom: 20px
        }

        #level-clear button {
            padding: 12px 40px;
            font-size: 16px;
            background: #00ffcc;
            color: #003d33;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold
        }
    </style>
</head>

<body>
    <div id="start-screen">
        <h1>字跑大师</h1>
        <div class="sub">Word Runner Master</div>
        <button id="start-btn">开始游戏</button>
    </div>
    <div id="wrap">
        <canvas id="gc"></canvas>
        <div id="hud">
            <div class="row"><span class="hearts" id="hud-hearts">❤️❤️❤️</span><span class="timer"
                    id="hud-timer">40s</span></div>
            <div class="task" id="hud-task">准备起跑</div>
            <div class="row"><span class="score" id="hud-score">0分</span><span class="level" id="hud-level">Lv.1
                    识字新兵</span></div>
            <div style="text-align:center"><span class="combo" id="hud-combo"></span></div>
        </div>
    </div>

    <div id="game-over">
        <h2>游戏结束</h2>
        <div class="stats" id="go-stats"></div><button id="go-restart">再来一局</button>
    </div>
    <div id="level-clear">
        <h2 id="lc-title">过关！</h2>
        <div class="info" id="lc-info"></div><button id="lc-next">下一关</button>
    </div>

    <script>
        // ========== 配置块（由 workbench.html 注入）==========
        window.WRM_CONFIG = {
            metadata: { version: "2.0.0", unitTitle: "人教版四年级上册·第一单元", playerName: "贝贝" },
            rules: {
                levelTime: 40,
                winCorrectTotal: 9,
                winCorrectStreak: 4,
                failWrongStreak: 4,
                initLives: 3,
                obstacleDamage: 1,
                wrongDamage: 0.5
            },
            difficulty: {
                speedStart: 2, speedEnd: 6,
                intervalStart: 2000, intervalEnd: 800,
                obstacleStart: 0.10, obstacleEnd: 0.40,
                wrongStart: 0.20, wrongEnd: 0.45,
                correctStart: 0.70, correctEnd: 0.15
            },
            scoring: {
                correctBase: 100, comboMax: 5,
                dodgeObstacle: 20, levelClear: 500,
                timeBonus: 10, streakBonus: 200
            },
            levels: [
                { rank: "识字新兵", threshold: 0 },
                { rank: "拼音学徒", threshold: 1000 },
                { rank: "汉字猎手", threshold: 3000 },
                { rank: "文字侠客", threshold: 6000 },
                { rank: "字跑大师", threshold: 10000 },
                { rank: "传奇字神", threshold: 20000 }
            ],
            physics: {
                tracksX: [0.166666, 0.5, 0.833333], // v2.9.2: 真正三等分跑道（1/6, 1/2, 5/6）
                playerY: 0.90, // 下移至 90%
                gravity: 2000,
                jumpForce: 750,
                objScaleStart: 0.08, // 物体远端缩放
                objScaleEnd: 1.0,     // 物体近端缩放
                playerScale: 1.5,     // 角色固定缩放
                obstacleScale: 1.0    // 障碍物额外缩放
            },
            levelDesign: {
                levelName: "音找字",                    // 关卡名称
                taskSource: "pinyin",                    // 任务区数据来源: pinyin | word
                correctSource: "word",                   // 正确项数据来源: word
                wrongSource: "word_exclude_homophone",   // 干扰项数据来源: word | word_exclude_homophone
                polyphoneRule: "use_data_pinyin",        // 多音字规则: use_data_pinyin | auto
                homophoneRule: "exclusive"               // 同音字规则: exclusive | allow_both
            },
            ui: { themeColor: "#00ffcc", isInvincible: false },
            dataSource: {
                offlineData: [
                    { "word": "潮", "pinyin": "cháo" }, { "word": "盐", "pinyin": "yán" }, { "word": "薄", "pinyin": "bó" },
                    { "word": "屹", "pinyin": "yì" }, { "word": "昂", "pinyin": "áng" }, { "word": "鼎", "pinyin": "dǐng" },
                    { "word": "沸", "pinyin": "fèi" }, { "word": "据", "pinyin": "jù" }, { "word": "堤", "pinyin": "dī" },
                    { "word": "阔", "pinyin": "kuò" }, { "word": "盼", "pinyin": "pàn" }, { "word": "滚", "pinyin": "gǔn" },
                    { "word": "顿", "pinyin": "dùn" }, { "word": "逐", "pinyin": "zhú" }, { "word": "渐", "pinyin": "jiàn" },
                    { "word": "堵", "pinyin": "dǔ" }, { "word": "犹", "pinyin": "yóu" }, { "word": "贯", "pinyin": "guàn" },
                    { "word": "浩", "pinyin": "hào" }, { "word": "崩", "pinyin": "bēng" }, { "word": "震", "pinyin": "zhèn" },
                    { "word": "霎", "pinyin": "shà" }, { "word": "余", "pinyin": "yú" }, { "word": "淘", "pinyin": "táo" },
                    { "word": "牵", "pinyin": "qiān" }, { "word": "鹅", "pinyin": "é" }, { "word": "卵", "pinyin": "luǎn" },
                    { "word": "坑", "pinyin": "kēng" }, { "word": "洼", "pinyin": "wā" }, { "word": "填", "pinyin": "tián" },
                    { "word": "庄", "pinyin": "zhuāng" }, { "word": "稼", "pinyin": "jià" }, { "word": "俗", "pinyin": "sú" },
                    { "word": "跃", "pinyin": "yuè" }, { "word": "葡", "pinyin": "pú" }, { "word": "萄", "pinyin": "táo" },
                    { "word": "稻", "pinyin": "dào" }, { "word": "熟", "pinyin": "shú" }, { "word": "穗", "pinyin": "suì" },
                    { "word": "镀", "pinyin": "dù" }, { "word": "埂", "pinyin": "gěng" }, { "word": "烁", "pinyin": "shuò" },
                    { "word": "巢", "pinyin": "cháo" }, { "word": "苇", "pinyin": "wěi" }, { "word": "罗", "pinyin": "luó" },
                    { "word": "眠", "pinyin": "mián" }, { "word": "霸", "pinyin": "bà" }, { "word": "占", "pinyin": "zhàn" },
                    { "word": "昧", "pinyin": "mèi" }, { "word": "坠", "pinyin": "zhuì" }, { "word": "怀", "pinyin": "huái" }
                ]
            }
        };
        // ========== 配置块结束 ==========

        ; (function () {
            "use strict";
            const CFG = window.WRM_CONFIG;
            const W = 450, H = 800;
            const canvas = document.getElementById('gc');
            const ctx = canvas.getContext('2d');
            canvas.width = W; canvas.height = H;

            // ===== 自适应缩放 =====
            function resize() {
                const ww = window.innerWidth, wh = window.innerHeight;
                const scale = Math.min(ww / W, wh / H);
                canvas.style.width = (W * scale) + 'px';
                canvas.style.height = (H * scale) + 'px';
                const hud = document.getElementById('hud');
                hud.style.width = (W * scale) + 'px';
            }
            window.addEventListener('resize', resize); resize();

            // ===== 音频引擎 =====
            let audioCtx = null;
            function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); }
            function synth(freq, type, decay, vol) {
                ensureAudio();
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
                o.frequency.exponentialRampToValueAtTime(Math.max(freq * 0.01, 1), audioCtx.currentTime + decay);
                g.gain.setValueAtTime(vol, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + decay);
                o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + decay);
            }
            function speakWord(text) {
                if (!('speechSynthesis' in window)) return;
                const u = new SpeechSynthesisUtterance(text); u.lang = 'zh-CN'; u.rate = 0.85;
                window.speechSynthesis.speak(u);
            }
            let bgmNodes = [];
            function startBGM() {
                ensureAudio();
                const master = audioCtx.createGain(); master.gain.value = 0.03; master.connect(audioCtx.destination);
                [110, 165, 220, 330].forEach((f, i) => {
                    const o = audioCtx.createOscillator(); o.type = 'sine'; o.frequency.value = f; o.detune.value = i * 3;
                    o.connect(master); o.start(); bgmNodes.push(o);
                });
            }
            function stopBGM() { bgmNodes.forEach(o => { try { o.stop(); } catch (e) { } }); bgmNodes = []; }
            const SFX = {
                correct(data) {
                    synth(880, 'sine', 0.15, 0.25); synth(1100, 'sine', 0.2, 0.15);
                    // v2.8: 撞击正确项时只播放汉字读音
                    if (data.word) setTimeout(() => speakWord(data.word), 150);
                },
                wrong() { synth(150, 'sawtooth', 0.3, 0.2); synth(120, 'square', 0.2, 0.15); },
                hit() { synth(80, 'square', 0.15, 0.3); },
                jump() { synth(400, 'sine', 0.1, 0.1); synth(600, 'sine', 0.08, 0.08); },
                levelUp() { synth(523, 'sine', 0.2, 0.2); setTimeout(() => synth(659, 'sine', 0.2, 0.2), 150); setTimeout(() => synth(784, 'sine', 0.3, 0.2), 300); },
                gameOver() { synth(300, 'sawtooth', 0.5, 0.2); synth(200, 'sawtooth', 0.6, 0.15); }
            };

            // ===== 游戏状态 =====
            const ST = {
                running: false, paused: false, gameOver: false,
                lives: CFG.rules.initLives, score: 0, combo: 0, maxCombo: 0,
                levelIndex: 0, levelTime: 0, levelTimer: 0,
                correctTotal: 0, correctStreak: 0, wrongStreak: 0,
                currentPinyin: '', currentWord: '', currentCorrectWord: '', // v2.8: 本关唯一正确汉字
                trackIndex: 1, playerJump: 0, jumpVy: 0, isJumping: false, playerAnim: 0,
                landingScale: 1.0, // 落地挤压缩放
                isRunning: false, runSpeedMultiplier: 1.0, // v2.8: 跑动状态和速度倍率
                runAnimPhase: 0, // v2.8.3: 跑动动画阶段
                objects: [], particles: [], roadLines: [],
                streakLevels: 0, totalLevelsCleared: 0,
                completedWordCount: 0, // v2.8: 已完成的字数（用于显示总进度）
                failedLevelIndex: -1, // v2.8: 失败时的关卡索引
                ringCompleteAnim: 0, // v2.8: 外环完成动画进度
                appearedCorrectWords: new Set(), // v2.5: 跟踪已出现的同音字
                dt: 0, lastTime: 0, frameCount: 0
            };

            // ===== 关卡数据 =====
            const allData = CFG.dataSource.offlineData;
            let pinyinList = [...new Set(allData.map(d => d.pinyin))];

            // ===== 等级计算 =====
            function getLevel(score) {
                let lv = CFG.levels[0];
                for (const l of CFG.levels) { if (score >= l.threshold) lv = l; }
                return lv;
            }

            // ===== 难度曲线 =====
            function getDifficulty() {
                const t = Math.min(ST.levelTime / CFG.rules.levelTime, 1);
                const d = CFG.difficulty;
                const lerp = (a, b) => a + (b - a) * t;
                return {
                    speed: lerp(d.speedStart, d.speedEnd),
                    interval: lerp(d.intervalStart, d.intervalEnd),
                    pObstacle: lerp(d.obstacleStart, d.obstacleEnd),
                    pWrong: lerp(d.wrongStart, d.wrongEnd),
                    pCorrect: lerp(d.correctStart, d.correctEnd)
                };
            }

            // ===== localStorage 配置管理 =====
            function loadConfig() {
                try {
                    const saved = localStorage.getItem('WRM_UserConfig');
                    if (!saved) return;
                    const config = JSON.parse(saved);
                    Object.assign(CFG.ui, config.ui || {});
                    Object.assign(CFG.difficulty, config.difficulty || {});
                    Object.assign(CFG.rules, config.rules || {});
                    Object.assign(CFG.physics, config.physics || {});
                } catch (e) {
                    console.warn('Failed to load config:', e);
                }
            }
            function saveConfig() {
                try {
                    const config = {
                        ui: { isInvincible: CFG.ui.isInvincible },
                        difficulty: { ...CFG.difficulty },
                        rules: { ...CFG.rules },
                        physics: { ...CFG.physics }
                    };
                    localStorage.setItem('WRM_UserConfig', JSON.stringify(config));
                } catch (e) {
                    console.warn('Failed to save config:', e);
                }
            }

            // ===== 透视计算 =====
            const VP = { x: W / 2, y: 0 }; // y 将在 drawTrack 中动态计算
            function perspScale(y) {
                const t = (y - VP.y) / (H - VP.y);
                const sStart = CFG.physics.objScaleStart;
                const sEnd = CFG.physics.objScaleEnd;
                return sStart + (sEnd - sStart) * t;
            }
            // v2.9.3: 跑道透视缩放与物体缩放分离
            function trackScale(y) {
                const t = (y - VP.y) / (H - VP.y);
                const sStart = 0.08; // 跑道远端固定缩放
                const sEnd = 1.0;    // 跑道近端固定缩放
                return sStart + (sEnd - sStart) * t;
            }
            function trackX(trackIdx, y) {
                const s = trackScale(y); // 使用独立的跑道缩放
                const baseX = CFG.physics.tracksX[trackIdx] * W;

                const t = (y - VP.y) / (H - VP.y);
                // 将 0.25 改小（例如 0.1），跑道底部会扩张得更开，符合图片比例
                const shrinkFactor = 1.0 - t * 0.1;
                return VP.x + (baseX - VP.x) * s * shrinkFactor;
            }

            // ===== 粒子系统 =====
            function spawnParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    ST.particles.push({
                        x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8 - 3,
                        life: 1, decay: 0.01 + Math.random() * 0.02,
                        size: 2 + Math.random() * 4, color,
                        type: Math.random() > 0.5 ? 'circle' : 'star'
                    });
                }
            }
            function updateParticles() {
                for (let i = ST.particles.length - 1; i >= 0; i--) {
                    const p = ST.particles[i];
                    p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life -= p.decay;
                    if (p.life <= 0) ST.particles.splice(i, 1);
                }
            }
            function drawParticles() {
                ST.particles.forEach(p => {
                    ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                    if (p.type === 'circle') {
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill();
                    } else {
                        drawStar(p.x, p.y, p.size * p.life * 1.5);
                    }
                });
                ctx.globalAlpha = 1;
            }
            function drawStar(cx, cy, r) {
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const a = Math.PI * 2 * i / 5 - Math.PI / 2;
                    const x = cx + Math.cos(a) * r, y = cy + Math.sin(a) * r;
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                    const a2 = a + Math.PI / 5;
                    ctx.lineTo(cx + Math.cos(a2) * r * 0.4, cy + Math.sin(a2) * r * 0.4);
                }
                ctx.closePath(); ctx.fill();
            }

            // ===== 跑道绘制 =====
            function drawTrack() {
                // 1. 地面与天空背景
                const titleBottom = 20 + 36 + 10;
                const taskUIY = titleBottom + 80;
                VP.y = taskUIY;

                const grad = ctx.createLinearGradient(0, VP.y, 0, H);
                grad.addColorStop(0, '#131325'); grad.addColorStop(1, '#0a0a12');
                ctx.fillStyle = grad; ctx.fillRect(0, VP.y, W, H - VP.y);

                const sky = ctx.createLinearGradient(0, 0, 0, VP.y);
                sky.addColorStop(0, '#0a0a12'); sky.addColorStop(1, '#131325');
                ctx.fillStyle = sky; ctx.fillRect(0, 0, W, VP.y);

                // 2. 绘制图片中那种“横线边缘”
                const edgeCount = 20; // 边缘线段数量
                for (let i = 0; i < edgeCount; i++) {
                    // 使用非线性分布，让近处的线段更长
                    const t = i / (edgeCount - 1);
                    const yy = VP.y + (H - VP.y) * t;
                    const s = trackScale(yy); // v2.9.3: 使用 trackScale

                    // 计算当前高度的左右边界点
                    const laneWidth = trackX(1, yy) - trackX(0, yy);
                    const leftX = trackX(0, yy) - laneWidth * 0.8;
                    const rightX = trackX(2, yy) + laneWidth * 0.8;

                    ctx.strokeStyle = '#00ffcc';
                    ctx.lineWidth = 4 * s; // 越近越粗
                    const lineLen = 15 * s; // 线段长度

                    // 绘制左侧装饰短线
                    ctx.beginPath();
                    ctx.moveTo(leftX - lineLen, yy);
                    ctx.lineTo(leftX + lineLen, yy);
                    ctx.stroke();

                    // 绘制右侧装饰短线
                    ctx.beginPath();
                    ctx.moveTo(rightX - lineLen, yy);
                    ctx.lineTo(rightX + lineLen, yy);
                    ctx.stroke();
                }

                // 3. 绘制车道分隔虚线 (图片中的蓝色虚线)
                ctx.setLineDash([10, 20]);
                ctx.strokeStyle = 'rgba(0, 255, 204, 0.3)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 2; i++) {
                    const xBot = (trackX(i, H) + trackX(i + 1, H)) / 2;
                    ctx.beginPath();
                    ctx.moveTo(VP.x, VP.y);
                    ctx.lineTo(xBot, H);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // 4. 绘制横向深蓝网格线 (图片背景中的水平线)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                for (let i = 1; i <= 10; i++) {
                    const yy = VP.y + (H - VP.y) * (i / 10);
                    ctx.beginPath();
                    ctx.moveTo(0, yy);
                    ctx.lineTo(W, yy);
                    ctx.stroke();
                }

                // v2.9.1: 跑道外边界线 — 向左下角/右下角大幅扩散（参照 UI 截图）
                // 边界乘数 1.2 使跑道底部几乎覆盖整个画布宽度
                const laneWidth = trackX(1, H) - trackX(0, H);
                const leftBoundaryH = trackX(0, H) - laneWidth * 1.2;
                const rightBoundaryH = trackX(2, H) + laneWidth * 1.2;

                ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(VP.x, VP.y); ctx.lineTo(leftBoundaryH, H); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(VP.x, VP.y); ctx.lineTo(rightBoundaryH, H); ctx.stroke();

                // 跑道分隔线 (虚线增强) — 延伸至屏幕底部
                ctx.strokeStyle = 'rgba(100,200,255,0.35)';
                ctx.lineWidth = 2;
                ctx.shadowColor = 'rgba(100,200,255,0.3)';
                ctx.shadowBlur = 3;
                ctx.setLineDash([10, 15]);
                for (let i = 0; i < 2; i++) {
                    const xBot = (trackX(i, H) + trackX(i + 1, H)) / 2;
                    ctx.beginPath();
                    ctx.moveTo(VP.x, VP.y);
                    ctx.lineTo(xBot, H);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
                ctx.shadowBlur = 0;

                // v2.9: 横向网格线 — 扩展到角色位置下方（共16条，覆盖至屏幕底部）
                const gridCount = 16;
                for (let i = 0; i < gridCount; i++) {
                    const yy = VP.y + (H - VP.y) * (i / (gridCount - 4)); // 后4条超出角色位置
                    if (yy > H) break; // 不绘制画布外
                    const s = Math.min(trackScale(yy), CFG.physics.objScaleEnd); // v2.9.3: 使用trackScale
                    const alpha = Math.min(s * 0.1, 0.12);
                    ctx.strokeStyle = `rgba(255,255,255,${alpha})`; ctx.lineWidth = 1;
                    // 使用外推计算宽度（超出 H 的部分线性外推）
                    const lx0 = trackX(0, Math.min(yy, H));
                    const rx0 = trackX(2, Math.min(yy, H));
                    const lx1 = trackX(1, Math.min(yy, H));
                    const lx = lx0 - (lx1 - lx0) * 0.2;
                    const rx = rx0 + (rx0 - lx1) * 0.2;
                    ctx.beginPath(); ctx.moveTo(lx, yy); ctx.lineTo(rx, yy); ctx.stroke();
                }

                // v2.9.2: 移除两侧发光灯柱装饰

                // 移动的跑道装饰线
                ST.roadLines.forEach(rl => {
                    // 只在分割线位置画移动块
                    const s = perspScale(rl.y);
                    ctx.fillStyle = `rgba(0,255,204,${s * 0.2})`;
                    const h = s * 30;

                    // 绘制在两个分隔线位置
                    for (let i = 0; i < 2; i++) {
                        const xLeft = trackX(i, rl.y);
                        const xRight = trackX(i + 1, rl.y);
                        const cx = (xLeft + xRight) / 2;
                        const w = 4 * s;
                        ctx.fillRect(cx - w / 2, rl.y, w, h);
                    }
                });
            }
            function updateRoadLines() {
                const diff = getDifficulty();
                // 添加新线
                if (ST.frameCount % 15 === 0) {
                    ST.roadLines.push({ y: VP.y });
                }
                // v2.8: 移动（受跑动速度影响）
                for (let i = ST.roadLines.length - 1; i >= 0; i--) {
                    ST.roadLines[i].y += diff.speed * 1.5 * ST.runSpeedMultiplier;
                    if (ST.roadLines[i].y > H) ST.roadLines.splice(i, 1);
                }
            }

            // ===== 跳跃轨迹绘制 =====
            function drawJumpTrajectory() {
                if (!ST.isJumping) return;

                ctx.save();
                ctx.strokeStyle = CFG.ui.themeColor;
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 8]); // 细虚线
                ctx.shadowColor = CFG.ui.themeColor;
                ctx.shadowBlur = 8; // 霓虹发光

                ctx.beginPath();
                const px = trackX(ST.trackIndex, H * CFG.physics.playerY);
                const py = H * CFG.physics.playerY - ST.playerJump;

                // 模拟抛物线轨迹
                let simY = ST.playerJump;
                let simVy = ST.jumpVy;
                const dt = 1 / 60;

                ctx.moveTo(px, py);
                let landingY = py;
                for (let i = 0; i < 60 && simY >= 0; i++) {
                    simY += simVy * dt;
                    simVy -= CFG.physics.gravity * dt;
                    const nextY = H * CFG.physics.playerY - simY;
                    ctx.lineTo(px, nextY);
                    landingY = nextY;
                }

                ctx.stroke();
                ctx.setLineDash([]);

                // v2.5: 计算落点位置（考虑游戏速度）
                const jumpDuration = (2 * Math.abs(ST.jumpVy)) / CFG.physics.gravity;
                const diff = getDifficulty();
                const fallDistance = diff.speed * jumpDuration;
                const targetY = Math.min(H, landingY + fallDistance);

                // 绘制目标落点标记
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(px, targetY, 6, 0, Math.PI * 2);
                ctx.fillStyle = CFG.ui.themeColor;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(px, targetY, 10, 0, Math.PI * 2);
                ctx.strokeStyle = CFG.ui.themeColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            // ===== v2.6: 角色绘制（正面视角，面朝任务区奔跑）=====
            function drawPlayer() {
                const ti = ST.trackIndex;
                const py = H * CFG.physics.playerY;
                const px = trackX(ti, py);
                const baseScale = CFG.physics.playerScale;
                const sX = baseScale * (2 - ST.landingScale);
                const sY = baseScale * ST.landingScale;

                const jy = ST.playerJump;
                const t = ST.playerAnim; // 始终递增，始终奔跑
                const tc = CFG.ui.themeColor;

                // 奔跑周期（始终运行）
                // v2.8.3: 跑动状态使用独立动画相位
                const animPhase = ST.isRunning ? ST.runAnimPhase : t;
                const runCycle = Math.sin(animPhase);
                const runCycle2 = Math.cos(animPhase);

                // v2.9.2: 身体上下颠簸 (bobbing)
                let bobbing = 0;
                if (ST.isRunning && !ST.isJumping) {
                    bobbing = Math.abs(Math.sin(animPhase * 2)) * 6 * sY;
                }
                const by = py - jy - bobbing;

                // 影子
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.35)';
                const shadowScale = Math.max(0.2, 1 - jy / 200);
                ctx.beginPath(); ctx.ellipse(px, py + 8 * sY, 18 * sX * shadowScale, 5 * sY * shadowScale, 0, 0, Math.PI * 2); ctx.fill();

                // 恢复落地形变
                if (ST.landingScale < 1.0) {
                    ST.landingScale += 0.05;
                    if (ST.landingScale > 1.0) ST.landingScale = 1.0;
                }

                const headR = 8 * sY;
                const bodyW = 14 * sX, bodyH = 20 * sY;
                const limbW = 4 * sX;

                // === 正面视角：腿部前后摆动（用Y偏移+缩放模拟透视）===
                // v2.9.2: 增强跑动幅度
                const swingMultiplier = ST.isRunning ? 2.5 : 1.0;
                let legSwingY = runCycle * 12 * sY * swingMultiplier;   // Y方向前后摆
                let legSwingX = Math.abs(runCycle) * 3 * sX;           // 略微外扩

                if (ST.isJumping) {
                    legSwingY = 8 * sY;  // 跳跃时双腿收起
                    legSwingX = 2 * sX;
                }

                ctx.strokeStyle = tc; ctx.lineWidth = limbW; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                // 左腿（后→前摆动）
                ctx.beginPath();
                ctx.moveTo(px - 4 * sX, by - 4 * sY); // 髋
                ctx.lineTo(px - 4 * sX - legSwingX * 0.3, by + 10 * sY - legSwingY); // 膝
                ctx.lineTo(px - 4 * sX, by + 18 * sY - legSwingY * 0.5); // 脚
                ctx.stroke();
                // 右腿（反向）
                ctx.beginPath();
                ctx.moveTo(px + 4 * sX, by - 4 * sY);
                ctx.lineTo(px + 4 * sX + legSwingX * 0.3, by + 10 * sY + legSwingY);
                ctx.lineTo(px + 4 * sX, by + 18 * sY + legSwingY * 0.5);
                ctx.stroke();

                // 躯干
                ctx.fillStyle = tc;
                ctx.shadowColor = tc; ctx.shadowBlur = 10 * sY;
                roundRect(px - bodyW / 2, by - bodyH - headR * 0.5, bodyW, bodyH, 6 * sX);
                ctx.shadowBlur = 0;

                // 躯干高光
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                roundRect(px - bodyW / 2 + 2 * sX, by - bodyH - headR * 0.5 + 2 * sY, bodyW * 0.4, bodyH * 0.7, 4 * sX);

                // 头部（正面圆形）
                ctx.fillStyle = tc;
                ctx.shadowColor = tc; ctx.shadowBlur = 12 * sY;
                ctx.beginPath(); ctx.arc(px, by - bodyH - headR * 1.2, headR, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;

                // v2.7: 护目镜横条（背影视角，无光点）
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.ellipse(px, by - bodyH - headR * 1.2, headR * 0.8, headR * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // 手臂（正面：左右对称前后摆，与腿反向）
                // v2.8.3: 跑动状态下手臂摆动幅度更大
                let armSwingY = -runCycle * 10 * sY * swingMultiplier;
                if (ST.isJumping) armSwingY = -12 * sY;

                ctx.strokeStyle = tc; ctx.lineWidth = limbW * 0.85; ctx.lineCap = 'round';
                // 左臂
                ctx.beginPath();
                ctx.moveTo(px - bodyW / 2 - 1 * sX, by - bodyH + 4 * sY);
                ctx.lineTo(px - bodyW / 2 - 6 * sX, by - bodyH / 2 - armSwingY * 0.4);
                ctx.lineTo(px - bodyW / 2 - 4 * sX, by - bodyH / 2 + 8 * sY - armSwingY * 0.2);
                ctx.stroke();
                // 右臂
                ctx.beginPath();
                ctx.moveTo(px + bodyW / 2 + 1 * sX, by - bodyH + 4 * sY);
                ctx.lineTo(px + bodyW / 2 + 6 * sX, by - bodyH / 2 + armSwingY * 0.4);
                ctx.lineTo(px + bodyW / 2 + 4 * sX, by - bodyH / 2 + 8 * sY + armSwingY * 0.2);
                ctx.stroke();

                // 昵称
                const hue = (ST.frameCount * 2) % 360;
                ctx.font = `bold ${14 * sY}px "Microsoft YaHei"`; ctx.textAlign = 'center';
                ctx.shadowColor = `hsl(${hue},100%,60%)`; ctx.shadowBlur = 15;
                ctx.fillStyle = '#fff';
                ctx.fillText(CFG.metadata.playerName, px, by - bodyH - headR * 2.8);
                ctx.shadowBlur = 10;
                ctx.fillText(CFG.metadata.playerName, px, by - bodyH - headR * 2.8);
                ctx.shadowBlur = 0;

                ctx.restore();
            }

            // 圆角矩形辅助
            function roundRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath(); ctx.fill();
            }

            // HEX转RGB
            function hexToRGB(hex) {
                const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            }

            // ===== 圆形任务UI (中心点与消失点重合) =====
            // 绘制游戏标题
            function drawGameTitle() {
                ctx.save();
                ctx.font = 'bold 36px "Microsoft YaHei"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                // 霓虹发光效果
                ctx.shadowColor = '#00ffcc';
                ctx.shadowBlur = 20;
                ctx.fillStyle = '#00ffcc';

                ctx.fillText('字跑大师', W / 2, 20);
                ctx.restore();
            }

            function drawTaskRing() {
                // 固定在标题下方
                const titleBottom = 20 + 36 + 10; // 标题 y=20, 高度 36, 间距 10
                const cx = W / 2;
                const cy = titleBottom + 80; // 标题下方 80px
                const ringR = W / 6; // 直径 ≈ 1/3 屏宽
                const tc = CFG.ui.themeColor;
                const tcRGB = hexToRGB(tc);

                ctx.save();

                // 背景圆（半透明暗色）
                ctx.beginPath(); ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(10,10,18,0.75)'; ctx.fill();

                // v2.8: 外环分格进度（9格，每撞击一个正确项点亮一格）
                const segmentCount = CFG.rules.winCorrectTotal; // 9格
                const segmentAngle = (Math.PI * 2) / segmentCount;
                const startAngle = -Math.PI / 2;

                for (let i = 0; i < segmentCount; i++) {
                    const segStart = startAngle + i * segmentAngle;
                    const segEnd = segStart + segmentAngle;
                    const gap = 0.05; // 格子间隙

                    ctx.beginPath();
                    ctx.arc(cx, cy, ringR, segStart + gap, segEnd - gap);

                    if (i < ST.correctTotal) {
                        // 已点亮的格子
                        ctx.strokeStyle = tc;
                        ctx.shadowColor = tc;
                        ctx.shadowBlur = 18;
                        ctx.lineWidth = 5;
                    } else {
                        // 未点亮的格子
                        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
                        ctx.shadowBlur = 0;
                        ctx.lineWidth = 5;
                    }
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;

                // v2.8: 通关动画（闪烁效果）
                if (ST.ringCompleteAnim > 0) {
                    const pulse = Math.sin(ST.ringCompleteAnim * 20) * 0.5 + 0.5;
                    ctx.shadowColor = tc;
                    ctx.shadowBlur = 30 * pulse;
                    ctx.beginPath();
                    ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
                    ctx.strokeStyle = tc;
                    ctx.globalAlpha = pulse * 0.8;
                    ctx.lineWidth = 8;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                    ST.ringCompleteAnim -= 0.05;
                    if (ST.ringCompleteAnim < 0) ST.ringCompleteAnim = 0;
                }

                // 拼音文字（居中大字）
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.font = `bold ${Math.floor(ringR * 0.45)}px "Microsoft YaHei"`;
                ctx.shadowColor = tc; ctx.shadowBlur = 10;
                ctx.fillStyle = '#fff';
                ctx.fillText(ST.currentPinyin || '--', cx, cy - 4);
                ctx.shadowBlur = 0;

                // v2.8.1: 移除连击提示显示

                // v2.8: 进度数字（显示总任务进度）
                ctx.font = `bold ${Math.floor(ringR * 0.22)}px "Microsoft YaHei"`;
                ctx.fillStyle = tc;
                ctx.fillText(`${ST.completedWordCount + 1}/${allData.length}`, cx, cy + ringR * 0.45);

                ctx.textBaseline = 'alphabetic';
                ctx.restore();
            }

            // ===== 物体系统 =====
            function spawnObject() {
                if (ST.paused || ST.gameOver || !ST.running) return;
                const diff = getDifficulty();
                let r = Math.random();
                let type, word = '', pinyin = '';

                // v2.6: 正确项生成保障 — 确保关卡内能出现足够的正确项
                const remaining = CFG.rules.levelTime - ST.levelTime;
                const needed = CFG.rules.winCorrectTotal - ST.correctTotal;
                if (needed > 0 && remaining > 0) {
                    const avgInterval = (CFG.difficulty.intervalStart + CFG.difficulty.intervalEnd) / 2;
                    const estimatedSpawns = remaining * 1000 / avgInterval;
                    const pCorrect = diff.pCorrect || (1 - diff.pObstacle - diff.pWrong);
                    if (estimatedSpawns * pCorrect < needed * 1.8) {
                        r = 1.0; // 强制落入 correct 区间
                    }
                }

                // 确定物体类型
                const pObs = diff.pObstacle;
                const pWrong = diff.pWrong;
                // pCorrect is the rest

                if (r < pObs) {
                    type = 'obstacle';
                } else if (r < pObs + pWrong) {
                    type = 'wrong';
                    // v2.8: 严格排除同音字 — 干扰项不能是任何与当前拼音相同的汉字
                    const correctWords = allData.filter(d => d.pinyin === ST.currentPinyin).map(d => d.word);
                    const pool = allData.filter(d => d.pinyin !== ST.currentPinyin && !correctWords.includes(d.word));
                    if (pool.length > 0) { const item = pool[Math.floor(Math.random() * pool.length)]; word = item.word; pinyin = item.pinyin; }
                    else { type = 'obstacle'; } // fallback
                } else {
                    type = 'correct';
                    // v2.8: 只生成本关的唯一正确汉字
                    if (ST.currentCorrectWord) {
                        word = ST.currentCorrectWord;
                        pinyin = ST.currentPinyin;
                    } else {
                        type = 'obstacle'; // fallback
                    }
                }

                // 选择跑道（不在同一跑道放相同干扰项）
                let track = Math.floor(Math.random() * 3);
                const existingOnTrack = ST.objects.filter(o => o.track === track && o.y < VP.y + 100);
                if (existingOnTrack.length > 0) track = (track + 1) % 3;

                ST.objects.push({
                    type, track, y: VP.y, word, pinyin,
                    alive: true, scale: 0.08
                });
            }

            function updateObjects() {
                const diff = getDifficulty();
                const py = H * CFG.physics.playerY;

                for (let i = ST.objects.length - 1; i >= 0; i--) {
                    const o = ST.objects[i];
                    // v2.8: 跑动时速度加倍
                    const speed = diff.speed * ST.runSpeedMultiplier;
                    o.y += speed;
                    o.scale = perspScale(o.y);

                    // 碰撞检测
                    if (o.alive && o.y > py - 40 && o.y < py + 20) {
                        const ox = trackX(o.track, o.y);
                        const px = trackX(ST.trackIndex, py);
                        const dist = Math.abs(ox - px);

                        if (dist < 30 * o.scale) {
                            // 玩家在跳跃中 → 跳过
                            if (ST.isJumping && ST.playerJump > 30) {
                                if (o.type === 'obstacle') {
                                    ST.score += CFG.scoring.dodgeObstacle;
                                }
                                // 跳过不触发碰撞
                            } else {
                                handleCollision(o);
                            }
                            o.alive = false;
                        }
                    }

                    // 移出屏幕
                    if (o.y > H + 50) {
                        ST.objects.splice(i, 1);
                    }
                }
            }

            function drawObjects() {
                ST.objects.forEach(o => {
                    if (!o.alive) return;
                    const x = trackX(o.track, o.y);
                    let s = o.scale;

                    // 障碍物应用额外缩放
                    if (o.type === 'obstacle') {
                        s = s * CFG.physics.obstacleScale;
                    }

                    if (o.type === 'obstacle') {
                        // v2.6: 建筑工程围栏
                        const sz = 22 * s;
                        const barW = sz * 2.2; // 栏杆宽度
                        const barH = sz * 1.4; // 栏杆高度
                        const postW = 4 * s;

                        // 左右立柱
                        ctx.fillStyle = '#ff8c00';
                        ctx.fillRect(x - barW / 2, o.y - barH / 2, postW, barH);
                        ctx.fillRect(x + barW / 2 - postW, o.y - barH / 2, postW, barH);

                        // 红白交替条纹横栏
                        const stripeCount = 5;
                        const stripeW = (barW - postW * 2) / stripeCount;
                        for (let si = 0; si < stripeCount; si++) {
                            ctx.fillStyle = si % 2 === 0 ? '#ff3333' : '#ffffff';
                            ctx.fillRect(x - barW / 2 + postW + si * stripeW, o.y - barH * 0.15, stripeW, barH * 0.3);
                        }

                        // 围栏边框
                        ctx.strokeStyle = '#ff6600'; ctx.lineWidth = 1.5 * s;
                        ctx.strokeRect(x - barW / 2, o.y - barH / 2, barW, barH);

                        // ⚠ 警告标志（中央三角）
                        const triSz = sz * 0.5;
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.moveTo(x, o.y - barH * 0.45 - triSz * 0.6);
                        ctx.lineTo(x - triSz * 0.5, o.y - barH * 0.45 + triSz * 0.3);
                        ctx.lineTo(x + triSz * 0.5, o.y - barH * 0.45 + triSz * 0.3);
                        ctx.closePath(); ctx.fill();
                        ctx.strokeStyle = '#333'; ctx.lineWidth = 1 * s; ctx.stroke();
                        // 感叹号
                        ctx.fillStyle = '#333'; ctx.font = `bold ${8 * s}px sans-serif`; ctx.textAlign = 'center';
                        ctx.fillText('!', x, o.y - barH * 0.45 + triSz * 0.15);

                        // 顶部闪烁灯
                        const blink = Math.sin(ST.frameCount * 0.15) > 0;
                        if (blink) {
                            ctx.fillStyle = '#ff0000';
                            ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 8 * s;
                            ctx.beginPath(); ctx.arc(x, o.y - barH / 2 - 3 * s, 3 * s, 0, Math.PI * 2); ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    } else {
                        // 气泡 (干扰项与正确项完全一致)
                        const radius = 22 * s;
                        ctx.beginPath(); ctx.arc(x, o.y, radius, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1.5 * s; ctx.stroke();
                        // 汉字
                        ctx.fillStyle = '#fff'; ctx.font = `bold ${22 * s}px "Microsoft YaHei"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(o.word, x, o.y);
                        ctx.textBaseline = 'alphabetic';
                    }
                });
            }

            // ===== 碰撞处理 =====
            function handleCollision(o) {
                // v2.8.6: 通关动画期间无敌
                if (ST.isCompletingLevel && o.type !== 'correct') return;
                if (CFG.ui.isInvincible && o.type !== 'correct') return;

                if (o.type === 'obstacle') {
                    ST.lives -= CFG.rules.obstacleDamage;
                    SFX.hit();
                    ST.combo = 0; ST.wrongStreak = 0;
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff3c3c', 15);
                } else if (o.type === 'wrong') {
                    ST.lives -= CFG.rules.wrongDamage;
                    SFX.wrong();
                    ST.combo = 0;
                    ST.wrongStreak++;
                    ST.correctStreak = 0;
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff6b6b', 10);
                } else if (o.type === 'correct') {
                    ST.combo++;
                    if (ST.combo > ST.maxCombo) ST.maxCombo = ST.combo;
                    const multiplier = Math.min(ST.combo, CFG.scoring.comboMax);
                    ST.score += CFG.scoring.correctBase * multiplier;
                    ST.correctTotal++;
                    ST.correctStreak++;
                    ST.wrongStreak = 0;
                    SFX.correct({ pinyin: ST.currentPinyin, word: o.word }); // v2.8: 传入word用于播放汉字读音
                    spawnParticles(trackX(o.track, o.y), o.y, '#00ffcc', 25);
                    spawnParticles(trackX(o.track, o.y), o.y, '#ffd700', 15);
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff69b4', 10);
                }

                // v2.8.6: 每次连击重置显示时间
                if (ST.combo >= 2) ST.comboDisplayTimer = 0.8; // 0.8秒后消失

                updateHUD();
                checkLevelState();
            }

            // ===== 关卡检查 =====
            function checkLevelState() {
                if (ST.lives <= 0) {
                    endGame(); return;
                }
                // 连击4个错误 → 失败
                if (ST.wrongStreak >= CFG.rules.failWrongStreak) {
                    endGame(); return;
                }
                // 累计9个正确 或 连续4个正确 → 过关
                // v2.8.6: 延迟通关逻辑
                const isWin = ST.correctTotal >= CFG.rules.winCorrectTotal || ST.correctStreak >= CFG.rules.winCorrectStreak;

                if (isWin && !ST.isCompletingLevel) {
                    // 开始通关流程：光环动画 -> 延迟 -> 弹窗
                    ST.isCompletingLevel = true;
                    ST.ringCompleteAnim = 1.0; // 触发外环闪烁动画
                    SFX.levelUp(); // 播放音效

                    // 1.5秒后显示结算界面
                    setTimeout(() => {
                        clearLevel();
                    }, 1500);
                }
            }

            function clearLevel() {
                ST.paused = true;
                ST.totalLevelsCleared++;
                ST.streakLevels++;
                // ST.ringCompleteAnim = 1.0; // 移至 checkLevelState 提前触发

                // 积分奖励
                const remaining = CFG.rules.levelTime - ST.levelTime;
                ST.score += CFG.scoring.levelClear + Math.floor(remaining) * CFG.scoring.timeBonus;
                ST.score += ST.streakLevels * CFG.scoring.streakBonus;
                SFX.levelUp();

                // v2.8: 累加已完成的字数
                ST.completedWordCount++;

                // v2.8.2: 修正通关简报显示
                const lcInfo = document.getElementById('lc-info');
                const justPassedLevel = ST.levelIndex + 1; // 刚通过的是第X关

                // 通关标题
                document.querySelector('#level-clear h2').textContent = `第${justPassedLevel}关 通过！`;

                // v2.8: 任务简报只显示本关的正确汉字
                lcInfo.innerHTML = `任务：${ST.currentPinyin} → ${ST.currentCorrectWord}<br>正确：${ST.correctTotal}个 | 连击：${ST.maxCombo}<br>得分：${ST.score}分<br>等级：${getLevel(ST.score).rank}`;

                document.getElementById('level-clear').style.display = 'flex';
            }

            function nextLevel() {
                document.getElementById('level-clear').style.display = 'none';
                ST.levelIndex++;
                if (ST.levelIndex >= pinyinList.length) {
                    // 所有关卡完成
                    endGame(true); return;
                }
                startLevel();
            }

            function startLevel() {
                ST.levelTime = 0; ST.correctTotal = 0; ST.correctStreak = 0; ST.wrongStreak = 0; ST.combo = 0; ST.maxCombo = 0;
                ST.comboDisplayTimer = 0; // v2.8.6: 连击显示计时器
                ST.isCompletingLevel = false; // v2.8.6: 重置通关状态
                ST.objects = []; ST.particles = [];
                ST.appearedCorrectWords.clear(); // v2.5: 重置同音字记录
                ST.currentPinyin = pinyinList[ST.levelIndex];
                const matches = allData.filter(d => d.pinyin === ST.currentPinyin);
                // v2.8: 为本关选择唯一的正确汉字
                if (matches.length > 0) {
                    const selectedItem = matches[Math.floor(Math.random() * matches.length)];
                    ST.currentCorrectWord = selectedItem.word;
                    ST.currentWord = selectedItem.word; // 只显示本关的正确汉字
                } else {
                    ST.currentCorrectWord = '';
                    ST.currentWord = ST.currentPinyin;
                }
                ST.paused = false;
                ST.levelTimer = 0;
                updateHUD();
                // v2.8: 任务提示音 - 播放汉字读音而非拼音
                setTimeout(() => speakWord(ST.currentCorrectWord || ST.currentPinyin), 300);
            }

            function endGame(allClear) {
                ST.gameOver = true; ST.running = false;
                if (!allClear) ST.failedLevelIndex = ST.levelIndex; // v2.8: 记录失败的关卡索引
                stopBGM();
                if (!allClear) SFX.gameOver(); else SFX.levelUp();
                const stats = document.getElementById('go-stats');
                const title = document.querySelector('#game-over h2');
                title.textContent = allClear ? '🎉 全部通关！' : '游戏结束';
                title.style.color = allClear ? '#00ffcc' : '#ff6b6b';
                // v2.8.1: 修复游戏结束统计信息，显示正确的进度
                const currentProgress = `${ST.completedWordCount}/${allData.length}`; // 当前已完成的字数
                const currentLevel = `第${ST.levelIndex + 1}关`; // 当前关卡
                stats.innerHTML = `当前进度：${currentProgress}<br>当前小关：${currentLevel}<br>总得分：${ST.score}<br>最高连击：${ST.maxCombo}<br>等级：${getLevel(ST.score).rank}`;
                document.getElementById('game-over').style.display = 'flex';
            }

            function restartGame() {
                document.getElementById('game-over').style.display = 'none';
                ST.lives = CFG.rules.initLives; ST.score = 0; ST.combo = 0; ST.maxCombo = 0;
                // v2.8: 从失败的关卡重新开始，保持进度
                if (ST.failedLevelIndex >= 0) {
                    ST.levelIndex = ST.failedLevelIndex;
                    // completedWordCount 保持不变，显示当前进度
                } else {
                    ST.levelIndex = 0;
                    ST.completedWordCount = 0;
                }
                ST.totalLevelsCleared = 0; ST.streakLevels = 0;
                ST.objects = []; ST.particles = []; ST.roadLines = [];
                ST.appearedCorrectWords.clear();
                ST.lastTime = 0; // v2.6: 重置时间戳，修复 dt 异常
                ST.gameOver = false; ST.running = true; ST.paused = false;
                if (ST.failedLevelIndex < 0) shuffleArray(pinyinList); // 只在全新开始时打乱
                startLevel();
                startBGM();
            }

            // ===== HUD 更新 =====
            function updateHUD() {
                // 分数 & 生命
                // 生命值 (支持半心)
                let hearts = '';
                const full = Math.floor(ST.lives);
                const half = ST.lives % 1 >= 0.5 ? 1 : 0;
                const empty = Math.max(0, CFG.rules.initLives - full - half);
                for (let i = 0; i < full; i++) hearts += '❤️';
                if (half) hearts += '💔';
                for (let i = 0; i < empty; i++) hearts += '🖤';
                document.getElementById('hud-hearts').textContent = hearts;

                // 时间
                const remaining = Math.max(0, Math.ceil(CFG.rules.levelTime - ST.levelTime));
                document.getElementById('hud-timer').textContent = remaining + 's';
                document.getElementById('hud-timer').style.color = remaining <= 10 ? '#ff3c3c' : '#ff6b6b';

                // 任务
                document.getElementById('hud-task').textContent = `任务：${ST.currentPinyin}`;

                // 分数
                document.getElementById('hud-score').textContent = ST.score + '分';

                // 等级
                const lv = getLevel(ST.score);
                const lvIdx = CFG.levels.indexOf(lv) + 1;
                document.getElementById('hud-level').textContent = `Lv.${lvIdx} ${lv.rank}`;

                // v2.8.6: 连击提示优化（带动画）
                const comboEl = document.getElementById('hud-combo');
                if (ST.combo >= 2 && ST.comboDisplayTimer > 0) {
                    comboEl.textContent = `🔥 ${ST.combo}连击！`;
                    comboEl.classList.remove('fade-out');
                    comboEl.style.opacity = '1';
                } else {
                    comboEl.classList.add('fade-out');
                    // opacity由CSS处理
                }
            }

            // ===== 物体生成计时器 =====
            let spawnTimer = 0;
            function updateSpawner(dt) {
                const diff = getDifficulty();
                spawnTimer += dt * 1000;
                if (spawnTimer >= diff.interval) {
                    spawnObject();
                    spawnTimer = 0;
                }
            }

            // ===== 主循环 =====
            function gameLoop(timestamp) {
                requestAnimationFrame(gameLoop);
                if (!ST.running) return;
                if (ST.lastTime === 0) ST.lastTime = timestamp;
                const dt = Math.min((timestamp - ST.lastTime) / 1000, 0.05);
                ST.lastTime = timestamp; ST.frameCount++;
                if (ST.paused) return;

                // 关卡计时
                // 关卡计时
                // v2.8.6: 通关动画期间停止计时
                if (!ST.isCompletingLevel) {
                    ST.levelTime += dt;
                    if (ST.levelTime >= CFG.rules.levelTime) {
                        endGame(); return;
                    }
                }

                // v2.8.6: 更新连击计时器
                if (ST.comboDisplayTimer > 0) {
                    ST.comboDisplayTimer -= dt;
                    if (ST.comboDisplayTimer <= 0) updateHUD(); // 触发消失动画
                }

                // v2.8.3: 检测长按并更新跑动状态
                updateRunningState();

                // v2.8: 角色动画（跑动比走动快）
                const animSpeed = ST.isRunning ? 0.2 : 0.12;
                ST.playerAnim += animSpeed;

                // 跳跃物理
                // 跳跃物理 update
                if (ST.isJumping) {
                    ST.playerJump += ST.jumpVy * dt;
                    ST.jumpVy -= CFG.physics.gravity * dt;

                    // 落地检测
                    if (ST.playerJump <= 0) {
                        ST.playerJump = 0;
                        ST.isJumping = false;
                        // 落地特效
                        SFX.hit(); // 或者单独的 land 音效
                        spawnParticles(trackX(ST.trackIndex, H * CFG.physics.playerY), H * CFG.physics.playerY, '#fff', 5);
                        ST.landingScale = 0.6; // 触发挤压动画
                    }
                }

                // 更新
                updateRoadLines();
                updateSpawner(dt);
                updateObjects();
                updateParticles();
                updateHUD();

                // 绘制
                ctx.clearRect(0, 0, W, H);
                drawTrack();
                drawGameTitle();
                drawTaskRing();
                drawJumpTrajectory();
                drawObjects();
                drawPlayer();
                drawParticles();
            }

            // v2.8.3: 跳跃 (物理驱动，支持原地跳和跑动跳)
            function jumpPlayer(isRunJump = false) {
                if (ST.isJumping || !ST.running || ST.paused) return;
                ST.isJumping = true;
                // 跑动中跳跃力度更大
                ST.jumpVy = isRunJump ? CFG.physics.jumpForce * 1.3 : CFG.physics.jumpForce;
                SFX.jump();
            }

            // ===== 车道切换 =====
            function movePlayer(dir) {
                if (!ST.running || ST.paused) return;
                ST.trackIndex = Math.max(0, Math.min(2, ST.trackIndex + dir));
            }

            // ===== 暂停 =====
            function togglePause() {
                if (!ST.running || ST.gameOver) return;
                ST.paused = !ST.paused;
                document.getElementById('hud-task').textContent = ST.paused ? '⏸ 已暂停' : `寻找拼音：${ST.currentPinyin}`;
            }

            // v2.8.3: 按键状态跟踪（用于单击/长按/双击检测）
            let lastUpKeyTime = 0;
            let upKeyPressed = false;
            let upKeyPressTime = 0;
            const LONG_PRESS_THRESHOLD = 200; // 长按阈值（毫秒）
            const DOUBLE_CLICK_THRESHOLD = 300; // 双击阈值（毫秒）

            // ===== 键盘输入 =====
            document.addEventListener('keydown', e => {
                if (e.code === 'ArrowUp' && !upKeyPressed) {
                    upKeyPressed = true;
                    upKeyPressTime = Date.now();
                    e.preventDefault();
                } else if (e.code === 'ArrowLeft') {
                    movePlayer(-1); e.preventDefault();
                } else if (e.code === 'ArrowRight') {
                    movePlayer(1); e.preventDefault();
                } else if (e.code === 'Space') {
                    togglePause(); e.preventDefault();
                }
            });

            document.addEventListener('keyup', e => {
                if (e.code === 'ArrowUp' && upKeyPressed) {
                    const now = Date.now();
                    const pressDuration = now - upKeyPressTime;
                    upKeyPressed = false;

                    // 判断是否为长按（跑动）
                    if (pressDuration >= LONG_PRESS_THRESHOLD) {
                        // 长按结束，停止跑动
                        ST.isRunning = false;
                        ST.runSpeedMultiplier = 1.0;
                    } else {
                        // 快速单击
                        // 检查是否为双击（在跑动状态下的双击跳跃）
                        if (ST.isRunning && now - lastUpKeyTime < DOUBLE_CLICK_THRESHOLD) {
                            // 跑动中双击 = 跑动跳跃
                            jumpPlayer(true);
                            lastUpKeyTime = 0;
                        } else {
                            // 单击 = 原地跳跃
                            jumpPlayer(false);
                            lastUpKeyTime = now;
                        }
                    }
                }
            });

            // v2.8.3: 检测长按并触发跑动
            function updateRunningState() {
                if (upKeyPressed && !ST.isRunning) {
                    const pressDuration = Date.now() - upKeyPressTime;
                    if (pressDuration >= LONG_PRESS_THRESHOLD) {
                        ST.isRunning = true;
                        ST.runSpeedMultiplier = 2.0;
                    }
                }
                // 更新跑动动画
                if (ST.isRunning && !ST.paused) {
                    ST.runAnimPhase = (ST.runAnimPhase + 0.2) % (Math.PI * 2);
                }
            }

            // ===== 触摸手势 =====
            let touchStartX = 0, touchStartY = 0, touchStartTime = 0, lastTapTime = 0, lastUpTapTime = 0;
            document.addEventListener('touchstart', e => {
                const t = e.touches[0]; touchStartX = t.clientX; touchStartY = t.clientY; touchStartTime = Date.now();
                e.preventDefault();
            }, { passive: false });
            document.addEventListener('touchend', e => {
                const t = e.changedTouches[0];
                const dx = t.clientX - touchStartX, dy = t.clientY - touchStartY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const elapsed = Date.now() - touchStartTime;

                if (dist < 20 && elapsed < 300) {
                    // 点击 → 检查双击
                    const now = Date.now();
                    if (now - lastTapTime < 350) { togglePause(); lastTapTime = 0; }
                    else lastTapTime = now;
                } else if (dist > 30) {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        dx < 0 ? movePlayer(-1) : movePlayer(1);
                    } else if (dy < -30) {
                        // v2.8: 向上滑动 - 检测双击跳跃 vs 单击跑动
                        const now = Date.now();
                        if (now - lastUpTapTime < 300) {
                            jumpPlayer();
                            lastUpTapTime = 0;
                        } else {
                            ST.isRunning = true;
                            ST.runSpeedMultiplier = 2.0;
                            lastUpTapTime = now;
                            // 0.5秒后自动恢复走动
                            setTimeout(() => {
                                ST.isRunning = false;
                                ST.runSpeedMultiplier = 1.0;
                            }, 500);
                        }
                    }
                }
                e.preventDefault();
            }, { passive: false });


            // ===== 启动 =====
            // 页面加载时加载保存的配置
            loadConfig();
            // v2.9.1: 同步 ST.lives（loadConfig 在 ST 初始化之后执行，需手动同步）
            ST.lives = CFG.rules.initLives;

            document.getElementById('start-btn').onclick = () => {
                const ss = document.getElementById('start-screen');
                ss.style.opacity = '0';
                setTimeout(() => ss.remove(), 600);
                ensureAudio();
                // 预热 TTS
                const v = new SpeechSynthesisUtterance(''); v.volume = 0; window.speechSynthesis.speak(v);
                startBGM();
                ST.running = true;
                startLevel();
                requestAnimationFrame(gameLoop);
            };

            document.getElementById('go-restart').onclick = restartGame;
            document.getElementById('lc-next').onclick = nextLevel;

        })();
    </script>
</body>

</html>