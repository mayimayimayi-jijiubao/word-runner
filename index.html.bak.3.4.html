<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>字跑大师</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #2d3436;
            /* Deep Grey Background */
            font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
            touch-action: none;
            user-select: none
        }

        #wrap {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative
        }

        canvas {
            display: block;
            image-rendering: pixelated
        }

        /* HUD: Top Status Bar - All on Top Right */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Hearts -> Top Left */
        #hud .group-left {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Level & Score -> Top Right */
        #hud .group-right {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            /* Stack them for better fit */
            gap: 10px;
            align-items: flex-end;
        }

        /* Timer -> Center (Above Task Ring) */
        #hud-timer {
            position: absolute;
            top: 15%;
            /* Approx above ring */
            left: 50%;
            transform: translateX(-50%) rotate(-2deg);
            z-index: 10;
        }

        /* Hide the container row if it exists */
        #hud .row.top-bar {
            display: block;
        }

        /* Yellow Sticky Note Style with Lines */
        .hud-note {
            background-color: #ffeaa7;
            background-image: repeating-linear-gradient(transparent, transparent 19px, #ccc 20px);
            color: #2d3436;
            padding: 6px 12px;
            border-radius: 2px;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            font-weight: bold;
            font-size: 14px;
            text-shadow: none;
            border: 1px solid #e0cba0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 60px;
        }

        /* Specific rotations for natural feel */
        .hud-note:nth-child(odd) {
            transform: rotate(-1deg);
        }

        .hud-note:nth-child(even) {
            transform: rotate(1deg);
        }

        #hud .task {
            display: none
        }

        #hud-hearts {
            /* Hearts can be on white or yellow, user asked for yellow note background for status bar */
            color: #d63031;
        }

        #hud-score {
            color: #d63031;
            font-family: "Comic Sans MS", "Marker Felt", sans-serif;
            font-size: 20px;
        }

        #hud-level {
            font-size: 14px;
            color: #636e72;
        }

        #hud-timer {
            color: #d63031;
            font-family: monospace;
            font-size: 18px;
        }

        #hud .combo {
            position: absolute;
            top: 50%;
            /* Strictly Center */
            left: 50%;
            transform: translate(-50%, -50%);
            /* Strictly Center */
            font-size: 48px;
            color: #fdcb6e;
            text-shadow: 3px 3px 0 #d63031;
            font-weight: bold;
            opacity: 0;
            transition: opacity .1s, transform .1s;
            pointer-events: none;
            z-index: 20;
            white-space: nowrap;
        }

        #hud .combo.fade-out {
            opacity: 0 !important;
            transform: translate(-50%, -80%);
        }

        #start-screen {
            position: fixed;
            inset: 0;
            background-color: #2d3436;
            background-image: radial-gradient(circle at center, rgba(50, 50, 50, 0.5) 0%, rgba(0, 0, 0, 0.5) 100%);
            /* Pattern would be better, but simple dark grey works with the theme */
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: "Microsoft YaHei", sans-serif
        }

        #start-screen h1 {
            font-size: 64px;
            color: #EBE7DD;
            /* Runway Color */
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
            margin-bottom: 8px;
            letter-spacing: 6px;
            font-weight: bold;
        }

        #start-screen .sub {
            color: #b2bec3;
            font-size: 14px;
            margin-bottom: 60px
        }

        #start-screen button {
            padding: 16px 56px;
            font-size: 24px;
            /* Sticky Note Style */
            background-color: #ffeaa7;
            background-image: repeating-linear-gradient(transparent, transparent 19px, #ccc 20px);
            border: 1px solid #e0cba0;
            border-radius: 2px;
            cursor: pointer;
            font-weight: bold;
            color: #2d3436;
            box-shadow: 4px 4px 6px rgba(0, 0, 0, 0.4);
            transition: transform .2s, box-shadow .2s;
            transform: rotate(-2deg);
            font-family: "Microsoft YaHei", sans-serif;
        }

        #start-screen button:hover {
            transform: scale(1.05) rotate(-1deg);
            box-shadow: 6px 6px 10px rgba(0, 0, 0, 0.5)
        }


        /* Unified Popup Styles */
        #game-over,
        #pause-menu {
            position: fixed;
            inset: 0;
            background-color: rgba(45, 52, 54, 0.95);
            /* Dark Grey translucent */
            z-index: 210;
            /* Higher than level clear if needed */
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            backdrop-filter: blur(5px);
        }

        #game-over h2,
        #pause-menu h2 {
            font-size: 48px;
            color: #fdcb6e;
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }

        #game-over .stats,
        #pause-menu .info {
            font-size: 24px;
            color: #dfe6e9;
            line-height: 2;
            text-align: center;
            margin-bottom: 40px;
        }

        #game-over button,
        #pause-menu button {
            padding: 12px 40px;
            font-size: 24px;
            /* Sticky Note Style */
            background-color: #ffeaa7;
            background-image: repeating-linear-gradient(transparent, transparent 19px, #ccc 20px);
            border: 1px solid #e0cba0;
            border-radius: 2px;
            cursor: pointer;
            font-weight: bold;
            color: #2d3436;
            box-shadow: 4px 4px 6px rgba(0, 0, 0, 0.4);
            transform: rotate(1deg);
            transition: transform 0.2s;
            font-family: "Microsoft YaHei", sans-serif;
            margin-top: 20px;
        }

        #game-over button:hover,
        #pause-menu button:hover {
            transform: scale(1.05) rotate(0deg);
        }

        #level-clear {
            position: fixed;
            inset: 0;
            background-color: rgba(45, 52, 54, 0.95);
            /* Dark Grey translucent */
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            backdrop-filter: blur(5px);
        }

        #level-clear h2 {
            font-size: 48px;
            color: #fdcb6e;
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }

        #level-clear .info {
            font-size: 24px;
            color: #dfe6e9;
            line-height: 2;
            text-align: center;
            margin-bottom: 40px;
        }

        #level-clear button {
            padding: 12px 40px;
            font-size: 24px;
            /* Sticky Note Style */
            background-color: #ffeaa7;
            background-image: repeating-linear-gradient(transparent, transparent 19px, #ccc 20px);
            border: 1px solid #e0cba0;
            border-radius: 2px;
            cursor: pointer;
            font-weight: bold;
            color: #2d3436;
            box-shadow: 4px 4px 6px rgba(0, 0, 0, 0.4);
            transform: rotate(1deg);
            transition: transform 0.2s;
            font-family: "Microsoft YaHei", sans-serif;
        }

        #level-clear button:hover {
            transform: scale(1.05) rotate(0deg);
        }
    </style>
</head>

<body>
    <div id="start-screen">
        <h1>字跑大师</h1>
        <div class="sub">Word Runner Master</div>
        <button id="start-btn">开始游戏</button>
    </div>
    <div id="wrap">
        <canvas id="gc"></canvas>
        <div id="hud">
            <div class="row top-bar">
                <div class="group-left">
                    <span class="hud-note" id="hud-hearts">❤️❤️❤️</span>
                </div>

                <!-- Timer moved to center (will be positioned by CSS) -->
                <span class="hud-note" id="hud-timer">40s</span>

                <div class="group-right">
                    <span class="hud-note" id="hud-level">Lv.1 识字新兵</span>
                    <span class="hud-note" id="hud-score">0分</span>
                </div>
            </div>
            <div class="task" id="hud-task">准备起跑</div>
            <div style="text-align:center"><span id="hud-combo" class="combo"></span></div>
        </div>
    </div>

    <div id="game-over">
        <h2>游戏结束</h2>
        <div class="stats" id="go-stats"></div><button id="go-restart">再来一局</button>
    </div>
    <div id="level-clear">
        <h2 id="lc-title">过关！</h2>
        <div class="info" id="lc-info"></div><button id="lc-next">下一关</button>
    </div>

    <script>
        // ========== 配置块（由 workbench.html 注入）==========
        window.WRM_CONFIG = {
            metadata: { version: "3.0.0", unitTitle: "人教版四年级上册·第一单元", playerName: "贝贝" },
            rules: {
                levelTime: 40,
                winCorrectTotal: 9,
                winCorrectStreak: 4,
                failWrongStreak: 4,
                initLives: 3,
                obstacleDamage: 1,
                wrongDamage: 0.5
            },
            difficulty: {
                speedStart: 2, speedEnd: 6,
                intervalStart: 2000, intervalEnd: 800,
                obstacleStart: 0.10, obstacleEnd: 0.40,
                wrongStart: 0.20, wrongEnd: 0.45,
                correctStart: 0.70, correctEnd: 0.15
            },
            scoring: {
                correctBase: 100, comboMax: 5,
                dodgeObstacle: 20, levelClear: 500,
                timeBonus: 10, streakBonus: 200
            },
            levels: [
                { rank: "识字新兵", threshold: 0 },
                { rank: "拼音学徒", threshold: 1000 },
                { rank: "汉字猎手", threshold: 3000 },
                { rank: "文字侠客", threshold: 6000 },
                { rank: "字跑大师", threshold: 10000 },
                { rank: "传奇字神", threshold: 20000 }
            ],
            physics: {
                tracksX: [0.166666, 0.5, 0.833333], // v2.9.2: 真正三等分跑道（1/6, 1/2, 5/6）
                playerY: 0.90, // 下移至 90%
                gravity: 2000,
                jumpForce: 750,
                objScaleStart: 0.08, // 物体远端缩放
                objScaleEnd: 1.0,     // 物体近端缩放
                playerScale: 1.5,     // 角色固定缩放
                obstacleScale: 1.0    // 障碍物额外缩放
            },
            levelDesign: {
                levelName: "音找字",                    // 关卡名称
                taskSource: "pinyin",                    // 任务区数据来源: pinyin | word
                correctSource: "word",                   // 正确项数据来源: word
                wrongSource: "word_exclude_homophone",   // 干扰项数据来源: word | word_exclude_homophone
                polyphoneRule: "use_data_pinyin",        // 多音字规则: use_data_pinyin | auto
                homophoneRule: "exclusive"               // 同音字规则: exclusive | allow_both
            },
            ui: { themeColor: "#00ffcc", isInvincible: false },
            dataSource: {
                offlineData: [
                    { "word": "潮", "pinyin": "cháo" }, { "word": "盐", "pinyin": "yán" }, { "word": "薄", "pinyin": "bó" },
                    { "word": "屹", "pinyin": "yì" }, { "word": "昂", "pinyin": "áng" }, { "word": "鼎", "pinyin": "dǐng" },
                    { "word": "沸", "pinyin": "fèi" }, { "word": "据", "pinyin": "jù" }, { "word": "堤", "pinyin": "dī" },
                    { "word": "阔", "pinyin": "kuò" }, { "word": "盼", "pinyin": "pàn" }, { "word": "滚", "pinyin": "gǔn" },
                    { "word": "顿", "pinyin": "dùn" }, { "word": "逐", "pinyin": "zhú" }, { "word": "渐", "pinyin": "jiàn" },
                    { "word": "堵", "pinyin": "dǔ" }, { "word": "犹", "pinyin": "yóu" }, { "word": "贯", "pinyin": "guàn" },
                    { "word": "浩", "pinyin": "hào" }, { "word": "崩", "pinyin": "bēng" }, { "word": "震", "pinyin": "zhèn" },
                    { "word": "霎", "pinyin": "shà" }, { "word": "余", "pinyin": "yú" }, { "word": "淘", "pinyin": "táo" },
                    { "word": "牵", "pinyin": "qiān" }, { "word": "鹅", "pinyin": "é" }, { "word": "卵", "pinyin": "luǎn" },
                    { "word": "坑", "pinyin": "kēng" }, { "word": "洼", "pinyin": "wā" }, { "word": "填", "pinyin": "tián" },
                    { "word": "庄", "pinyin": "zhuāng" }, { "word": "稼", "pinyin": "jià" }, { "word": "俗", "pinyin": "sú" },
                    { "word": "跃", "pinyin": "yuè" }, { "word": "葡", "pinyin": "pú" }, { "word": "萄", "pinyin": "táo" },
                    { "word": "稻", "pinyin": "dào" }, { "word": "熟", "pinyin": "shú" }, { "word": "穗", "pinyin": "suì" },
                    { "word": "镀", "pinyin": "dù" }, { "word": "埂", "pinyin": "gěng" }, { "word": "烁", "pinyin": "shuò" },
                    { "word": "巢", "pinyin": "cháo" }, { "word": "苇", "pinyin": "wěi" }, { "word": "罗", "pinyin": "luó" },
                    { "word": "眠", "pinyin": "mián" }, { "word": "霸", "pinyin": "bà" }, { "word": "占", "pinyin": "zhàn" },
                    { "word": "昧", "pinyin": "mèi" }, { "word": "坠", "pinyin": "zhuì" }, { "word": "怀", "pinyin": "huái" }
                ]
            }
        };
        // ========== 配置块结束 ==========

        ; (function () {
            "use strict";
            const CFG = window.WRM_CONFIG;
            const W = 450, H = 800;
            const canvas = document.getElementById('gc');
            const ctx = canvas.getContext('2d');
            canvas.width = W; canvas.height = H;

            // ===== 自适应缩放 =====
            function resize() {
                const ww = window.innerWidth, wh = window.innerHeight;
                const scale = Math.min(ww / W, wh / H);
                canvas.style.width = (W * scale) + 'px';
                canvas.style.height = (H * scale) + 'px';
                const hud = document.getElementById('hud');
                hud.style.width = (W * scale) + 'px';
            }
            window.addEventListener('resize', resize); resize();

            // ===== 音频引擎 =====
            let audioCtx = null;
            function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); }
            function synth(freq, type, decay, vol) {
                ensureAudio();
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
                o.frequency.exponentialRampToValueAtTime(Math.max(freq * 0.01, 1), audioCtx.currentTime + decay);
                g.gain.setValueAtTime(vol, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + decay);
                o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + decay);
            }
            function speakWord(text) {
                if (!('speechSynthesis' in window)) return;
                const u = new SpeechSynthesisUtterance(text); u.lang = 'zh-CN'; u.rate = 0.85;
                window.speechSynthesis.speak(u);
            }
            let bgmNodes = [];
            function startBGM() {
                ensureAudio();
                const master = audioCtx.createGain(); master.gain.value = 0.03; master.connect(audioCtx.destination);
                [110, 165, 220, 330].forEach((f, i) => {
                    const o = audioCtx.createOscillator(); o.type = 'sine'; o.frequency.value = f; o.detune.value = i * 3;
                    o.connect(master); o.start(); bgmNodes.push(o);
                });
            }
            function stopBGM() { bgmNodes.forEach(o => { try { o.stop(); } catch (e) { } }); bgmNodes = []; }
            const SFX = {
                correct(data) {
                    synth(880, 'sine', 0.15, 0.25); synth(1100, 'sine', 0.2, 0.15);
                    // v2.8: 撞击正确项时只播放汉字读音
                    if (data.word) setTimeout(() => speakWord(data.word), 150);
                },
                wrong() { synth(150, 'sawtooth', 0.3, 0.2); synth(120, 'square', 0.2, 0.15); },
                hit() { synth(80, 'square', 0.15, 0.3); },
                jump() { synth(400, 'sine', 0.1, 0.1); synth(600, 'sine', 0.08, 0.08); },
                levelUp() { synth(523, 'sine', 0.2, 0.2); setTimeout(() => synth(659, 'sine', 0.2, 0.2), 150); setTimeout(() => synth(784, 'sine', 0.3, 0.2), 300); },
                gameOver() { synth(300, 'sawtooth', 0.5, 0.2); synth(200, 'sawtooth', 0.6, 0.15); }
            };

            // ===== 游戏状态 =====
            const ST = {
                running: false, paused: false, gameOver: false,
                lives: CFG.rules.initLives, score: 0, combo: 0, maxCombo: 0,
                levelIndex: 0, levelTime: 0, levelTimer: 0,
                correctTotal: 0, correctStreak: 0, wrongStreak: 0,
                currentPinyin: '', currentWord: '', currentCorrectWord: '', // v2.8: 本关唯一正确汉字
                trackIndex: 1, playerJump: 0, jumpVy: 0, isJumping: false, playerAnim: 0,
                landingScale: 1.0, // 落地挤压缩放
                isRunning: false, runSpeedMultiplier: 1.0, // v2.8: 跑动状态和速度倍率
                runAnimPhase: 0, // v2.8.3: 跑动动画阶段
                objects: [], particles: [], roadLines: [],
                streakLevels: 0, totalLevelsCleared: 0,
                completedWordCount: 0, // v2.8: 已完成的字数（用于显示总进度）
                failedLevelIndex: -1, // v2.8: 失败时的关卡索引
                ringCompleteAnim: 0, // v2.8: 外环完成动画进度
                appearedCorrectWords: new Set(), // v2.5: 跟踪已出现的同音字
                dt: 0, lastTime: 0, frameCount: 0
            };

            // ===== 关卡数据 =====
            const allData = CFG.dataSource.offlineData;
            let pinyinList = [...new Set(allData.map(d => d.pinyin))];

            // ===== 等级计算 =====
            function getLevel(score) {
                let lv = CFG.levels[0];
                for (const l of CFG.levels) { if (score >= l.threshold) lv = l; }
                return lv;
            }

            // ===== 难度曲线 =====
            function getDifficulty() {
                const t = Math.min(ST.levelTime / CFG.rules.levelTime, 1);
                const d = CFG.difficulty;
                const lerp = (a, b) => a + (b - a) * t;
                return {
                    speed: lerp(d.speedStart, d.speedEnd),
                    interval: lerp(d.intervalStart, d.intervalEnd),
                    pObstacle: lerp(d.obstacleStart, d.obstacleEnd),
                    pWrong: lerp(d.wrongStart, d.wrongEnd),
                    pCorrect: lerp(d.correctStart, d.correctEnd)
                };
            }

            // ===== localStorage 配置管理 =====
            function loadConfig() {
                try {
                    const saved = localStorage.getItem('WRM_UserConfig');
                    if (!saved) return;
                    const config = JSON.parse(saved);
                    Object.assign(CFG.ui, config.ui || {});
                    Object.assign(CFG.difficulty, config.difficulty || {});
                    Object.assign(CFG.rules, config.rules || {});
                    Object.assign(CFG.physics, config.physics || {});
                } catch (e) {
                    console.warn('Failed to load config:', e);
                }
            }
            function saveConfig() {
                try {
                    const config = {
                        ui: { isInvincible: CFG.ui.isInvincible },
                        difficulty: { ...CFG.difficulty },
                        rules: { ...CFG.rules },
                        physics: { ...CFG.physics }
                    };
                    localStorage.setItem('WRM_UserConfig', JSON.stringify(config));
                } catch (e) {
                    console.warn('Failed to save config:', e);
                }
            }

            // ===== 透视计算 =====
            const VP = { x: W / 2, y: 0 }; // y 将在 drawTrack 中动态计算
            function perspScale(y) {
                const t = (y - VP.y) / (H - VP.y);
                const sStart = CFG.physics.objScaleStart;
                const sEnd = CFG.physics.objScaleEnd;
                return sStart + (sEnd - sStart) * t;
            }
            // v2.9.3: 跑道透视缩放与物体缩放分离
            function trackScale(y) {
                const t = (y - VP.y) / (H - VP.y);
                const sStart = 0.08; // 跑道远端固定缩放
                const sEnd = 1.0;    // 跑道近端固定缩放
                return sStart + (sEnd - sStart) * t;
            }
            function trackX(trackIdx, y) {
                const s = trackScale(y); // 使用独立的跑道缩放
                const baseX = CFG.physics.tracksX[trackIdx] * W;

                const t = (y - VP.y) / (H - VP.y);
                // 将 0.25 改小（例如 0.1），跑道底部会扩张得更开，符合图片比例
                const shrinkFactor = 1.0 - t * 0.1;
                return VP.x + (baseX - VP.x) * s * shrinkFactor;
            }

            // ===== 粒子系统 =====
            function spawnParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    ST.particles.push({
                        x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8 - 3,
                        life: 1, decay: 0.01 + Math.random() * 0.02,
                        size: 2 + Math.random() * 4, color,
                        type: Math.random() > 0.5 ? 'circle' : 'star'
                    });
                }
            }
            function updateParticles() {
                for (let i = ST.particles.length - 1; i >= 0; i--) {
                    const p = ST.particles[i];
                    p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life -= p.decay;
                    if (p.life <= 0) ST.particles.splice(i, 1);
                }
            }
            function drawParticles() {
                ST.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    // v3.0: 纸屑风格粒子，无发光，旋转正方形或圆形
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.life * 5); // 旋转效果
                    if (p.type === 'circle') {
                        ctx.beginPath(); ctx.arc(0, 0, p.size * p.life, 0, Math.PI * 2); ctx.fill();
                    } else {
                        // 碎纸片 (方形)
                        ctx.fillRect(-p.size * p.life, -p.size * p.life, p.size * p.life * 2, p.size * p.life * 2);
                    }
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
            }
            function drawStar(cx, cy, r) {
                // 保留五角星逻辑，用于特效，但也可以简化
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const a = Math.PI * 2 * i / 5 - Math.PI / 2;
                    const x = cx + Math.cos(a) * r, y = cy + Math.sin(a) * r;
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                    const a2 = a + Math.PI / 5;
                    ctx.lineTo(cx + Math.cos(a2) * r * 0.4, cy + Math.sin(a2) * r * 0.4);
                }
                ctx.closePath(); ctx.fill();
            }

            // ===== v3.0: 纸质风格渲染辅助函数 (New Helper Functions) =====
            let paperPattern = null;
            function createPaperPattern() {
                if (paperPattern) return paperPattern;
                const pCanvas = document.createElement('canvas');
                pCanvas.width = 256; pCanvas.height = 256;
                const pCtx = pCanvas.getContext('2d');
                // 基础深灰色背景
                pCtx.fillStyle = '#2D3436';
                pCtx.fillRect(0, 0, 256, 256);
                // 添加噪点纹理
                for (let i = 0; i < 6000; i++) {
                    pCtx.fillStyle = 'rgba(255,255,255,0.03)';
                    pCtx.fillRect(Math.random() * 256, Math.random() * 256, 2, 2);
                }
                paperPattern = ctx.createPattern(pCanvas, 'repeat');
                return paperPattern;
            }

            // 绘制粗糙边缘路径 (Wobble Effect)
            function drawRoughPath(ctx, points, closePath = false) {
                if (points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                    const steps = Math.max(1, Math.floor(dist / 20)); // 每20px一个扰动点

                    for (let j = 1; j <= steps; j++) {
                        const t = j / steps;
                        const bx = p1.x + (p2.x - p1.x) * t;
                        const by = p1.y + (p2.y - p1.y) * t;
                        // 随机扰动 (-1.5 到 1.5)
                        const jitX = (Math.random() - 0.5) * 3;
                        const jitY = (Math.random() - 0.5) * 3;
                        ctx.lineTo(bx + jitX, by + jitY);
                    }
                }
                if (closePath) {
                    ctx.closePath();
                }
                // 不在这里 stroke/fill，留给调用者
            }

            // ===== 跑道绘制 (Paper Cutout Style) =====
            function drawTrack() {
                const titleBottom = 20 + 36 + 10;
                const taskUIY = titleBottom + 80;
                VP.y = taskUIY;

                // 1. 全屏背景 (纸张纹理)
                ctx.fillStyle = createPaperPattern();
                ctx.fillRect(0, 0, W, H);

                // 2. 绘制跑道主体 (大剪纸带)
                // 计算左右边缘的关键点
                const trackCheckPointsY = [VP.y, VP.y + (H - VP.y) * 0.25, VP.y + (H - VP.y) * 0.5, VP.y + (H - VP.y) * 0.75, H];
                const leftPoints = [];
                const rightPoints = [];

                trackCheckPointsY.forEach(y => {
                    const lBase = trackX(0, y);
                    const rBase = trackX(2, y);
                    const lw = rBase - lBase; // 两个车道宽 (因为 trackX是中心点)
                    // trackX(0)是左车道中心，trackX(2)是右车道中心。
                    // 跑道总左边缘 = trackX(0) - 0.5 * 单车道宽
                    // 跑道总右边缘 = trackX(2) + 0.5 * 单车道宽
                    // 但是 trackX 是基于 tracksX 配置 [1/6, 1/2, 5/6]
                    // 所以 trackX(1) - trackX(0) = 1/3 W * s
                    // 单车道宽 = trackX(1) - trackX(0)
                    const laneW = trackX(1, y) - trackX(0, y);

                    // 稍微加宽一点边缘作为跑道纸带边界
                    leftPoints.push({ x: trackX(0, y) - laneW * 0.6, y: y });
                    rightPoints.push({ x: trackX(2, y) + laneW * 0.6, y: y });
                });

                // 构建完整的多边形路径
                const polyPoints = [...leftPoints, ...rightPoints.reverse()];

                ctx.save();
                // 白色毛边阴影 (Hard Shadow)
                ctx.translate(2, 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                drawRoughPath(ctx, polyPoints, true);
                ctx.fill();
                ctx.translate(-2, -2);

                // 跑道本体 (深一点的米色或浅灰，模拟重叠纸张)
                ctx.fillStyle = '#EBE7DD'; // 略深于背景
                drawRoughPath(ctx, polyPoints, true);
                ctx.fill();

                // 边缘描边 (铅笔痕迹)
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();

                // 3. 绘制车道分隔线 (虚线剪裁效果)
                ctx.save();
                ctx.strokeStyle = 'rgba(0,0,0,0.15)'; // 淡淡的压痕色
                ctx.lineWidth = 2;
                ctx.setLineDash([15, 15]); // 宽虚线

                // 线1 (跑道 0|1 之间)
                // 线2 (跑道 1|2 之间)
                // trackX(0) 是第一车道中心。分隔线应在 trackX(0) + laneW/2
                // 其实 trackX(0)和trackX(1)的中点就是分隔线
                const divLines = [0, 1];
                divLines.forEach(idx => {
                    const points = [];
                    trackCheckPointsY.forEach(y => {
                        const x = (trackX(idx, y) + trackX(idx + 1, y)) / 2;
                        points.push({ x, y });
                    });

                    // 用 rough path 绘制虚线有点奇怪，直接画带抖动的虚线
                    // 这里简化，直接画直虚线，配合手绘风背景即可
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    points.forEach((p, i) => { if (i > 0) ctx.lineTo(p.x, p.y); });
                    ctx.stroke();
                });
                ctx.restore();

                // 4. 起跑线/装饰横线 (贴纸条)
                // 移动的跑道装饰线
                ST.roadLines.forEach(rl => {
                    const s = trackScale(rl.y);
                    const h = s * 20;

                    // 绘制在两个分隔线位置的小横贴纸
                    for (let i = 0; i < 2; i++) {
                        const xLeft = trackX(i, rl.y);
                        const xRight = trackX(i + 1, rl.y);
                        const cx = (xLeft + xRight) / 2;
                        const w = 30 * s;

                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(cx - w / 2, rl.y, w, h);
                    }
                });
            }
            function updateRoadLines() {
                const diff = getDifficulty();
                // 添加新线
                if (ST.frameCount % 15 === 0) {
                    ST.roadLines.push({ y: VP.y });
                }
                // v2.8: 移动（受跑动速度影响）
                for (let i = ST.roadLines.length - 1; i >= 0; i--) {
                    ST.roadLines[i].y += diff.speed * 1.5 * ST.runSpeedMultiplier;
                    if (ST.roadLines[i].y > H) ST.roadLines.splice(i, 1);
                }
            }

            // ===== 跳跃轨迹绘制 =====
            // ===== 跳跃轨迹绘制 (缝纫线风格) =====
            function drawJumpTrajectory() {
                if (!ST.isJumping) return;

                ctx.save();
                ctx.strokeStyle = '#555'; // 深色缝衣线
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // 明显的虚线

                ctx.beginPath();
                const px = trackX(ST.trackIndex, H * CFG.physics.playerY);
                const py = H * CFG.physics.playerY - ST.playerJump;

                // 模拟抛物线轨迹
                let simY = ST.playerJump;
                let simVy = ST.jumpVy;
                const dt = 1 / 60;

                ctx.moveTo(px, py);
                let landingY = py;
                for (let i = 0; i < 60 && simY >= 0; i++) {
                    simY += simVy * dt;
                    simVy -= CFG.physics.gravity * dt;
                    const nextY = H * CFG.physics.playerY - simY;
                    ctx.lineTo(px, nextY);
                    landingY = nextY;
                }

                ctx.stroke();
                ctx.setLineDash([]);

                // 落点标记 (已移除)

                ctx.restore();
            }

            // ===== v3.0: 纸偶角色绘制 (Paper Puppet - Back View & Scaled) =====
            function drawPlayer() {
                const ti = ST.trackIndex;
                const py = H * CFG.physics.playerY;
                const px = trackX(ti, py);
                const baseScale = CFG.physics.playerScale * 1.5; // v3.2: 放大 50%
                const sX = baseScale * (2 - ST.landingScale);
                const sY = baseScale * ST.landingScale;

                const jy = ST.playerJump;
                const t = ST.playerAnim;
                const tc = '#F7B731'; // 身体主色 (暖黄)
                const pantsColor = '#2D3436'; // 裤子深灰
                const skinColor = '#FFDAB9'; // 皮肤粉色

                const animPhase = ST.isRunning ? ST.runAnimPhase : t;
                const runCycle = Math.sin(animPhase);
                const runCycle2 = Math.cos(animPhase);

                // 身体颠簸
                let bobbing = 0;
                if (ST.isRunning && !ST.isJumping) {
                    bobbing = Math.abs(Math.sin(animPhase * 2)) * 6 * sY;
                }
                const by = py - jy - bobbing;

                // 影子 (硬边深色椭圆)
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; // 深色硬投影
                const shadowScale = Math.max(0.2, 1 - jy / 200);

                ctx.beginPath();
                ctx.ellipse(px + 4, py + 8 * sY + 2, 18 * sX * shadowScale, 5 * sY * shadowScale, 0, 0, Math.PI * 2);
                ctx.fill();

                // 恢复落地形变
                if (ST.landingScale < 1.0) {
                    ST.landingScale += 0.05;
                    if (ST.landingScale > 1.0) ST.landingScale = 1.0;
                }

                const headR = 10 * sY;
                const bodyW = 16 * sX, bodyH = 22 * sY;
                const limbW = 5 * sX;

                // 绘制纸偶部件函数
                function drawLimb(x1, y1, x2, y2, color, w) {
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    // 模拟剪纸边缘
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    // 铆钉
                    ctx.fillStyle = '#b2bec3';
                    ctx.beginPath(); ctx.arc(x1, y1, w * 0.3, 0, Math.PI * 2); ctx.fill();
                }

                // 增强跑动幅度
                const swingMultiplier = ST.isRunning ? 2.5 : 1.0;
                let legSwingY = runCycle * 12 * sY * swingMultiplier;
                let legSwingX = Math.abs(runCycle) * 3 * sX;

                if (ST.isJumping) {
                    legSwingY = 8 * sY;
                    legSwingX = 2 * sX;
                }

                // 下半身 (腿) - Leg drawing logic
                // 左腿
                drawLimb(px - 4 * sX, by - 4 * sY, px - 4 * sX - legSwingX * 0.3, by + 10 * sY - legSwingY, pantsColor, limbW); // 大腿
                drawLimb(px - 4 * sX - legSwingX * 0.3, by + 10 * sY - legSwingY, px - 4 * sX, by + 18 * sY - legSwingY * 0.5, pantsColor, limbW); // 小腿

                // 右腿
                drawLimb(px + 4 * sX, by - 4 * sY, px + 4 * sX + legSwingX * 0.3, by + 10 * sY + legSwingY, pantsColor, limbW);
                drawLimb(px + 4 * sX + legSwingX * 0.3, by + 10 * sY + legSwingY, px + 4 * sX, by + 18 * sY + legSwingY * 0.5, pantsColor, limbW);

                // 身体 (圆角矩形纸片) - 背面视角，无需领口装饰
                ctx.fillStyle = '#0984e3'; // 蓝色衣服
                const bodyRot = runCycle * 0.1;
                ctx.save();
                ctx.translate(px, by - bodyH / 2);
                ctx.rotate(bodyRot);
                roundRect(-bodyW / 2, -bodyH / 2, bodyW, bodyH, 4 * sX);
                // 背部装饰 (简单的线条或 Logo) - 可选
                // ctx.fillStyle = 'rgba(255,255,255,0.3)';
                // ctx.fillRect(-bodyW*0.3, -bodyH*0.2, bodyW*0.6, 2*sY);
                ctx.restore();

                // 头部 (背面 - 主要是头发)
                const headY = by - bodyH - headR * 0.8;

                // 1. 皮肤 (脖子/耳根部分)
                ctx.fillStyle = skinColor;
                ctx.beginPath(); ctx.arc(px, headY, headR, 0, Math.PI * 2); ctx.fill();

                // 2. 头发 (背面完全覆盖后脑勺)
                ctx.fillStyle = '#2d3436';
                ctx.beginPath();
                ctx.arc(px, headY, headR * 1.1, Math.PI, Math.PI * 2); // 上半球
                // 下部自然的短发发际线
                ctx.lineTo(px + headR * 1.1, headY + headR * 0.5);
                ctx.quadraticCurveTo(px, headY + headR * 1.2, px - headR * 1.1, headY + headR * 0.5);
                ctx.fill();

                // 手臂
                let armSwingY = -runCycle * 10 * sY * swingMultiplier;
                if (ST.isJumping) armSwingY = -12 * sY;

                // 左臂 (Swing opposite to legs usually, but here runCycle is same? runCycle2 is cos.
                // Standard: Left Leg forward -> Right Arm forward.
                // legSwing is based on sin(t).
                // Let's use cos(t) for arms or inverted sin.
                const armCycle = -runCycle;

                // Arms attached at shoulders
                const shoulderY = by - bodyH + 2 * sY;
                const armW = limbW * 0.9;

                // 左臂
                drawLimb(px - bodyW / 2, shoulderY, px - bodyW / 2 - 6 * sX, shoulderY + 8 * sY + armSwingY, skinColor, armW);
                drawLimb(px - bodyW / 2 - 6 * sX, shoulderY + 8 * sY + armSwingY, px - bodyW / 2 - 8 * sX, shoulderY + 16 * sY + armSwingY * 1.5, skinColor, armW);

                // 右臂
                drawLimb(px + bodyW / 2, shoulderY, px + bodyW / 2 + 6 * sX, shoulderY + 8 * sY - armSwingY, skinColor, armW);
                drawLimb(px + bodyW / 2 + 6 * sX, shoulderY + 8 * sY - armSwingY, px + bodyW / 2 + 8 * sX, shoulderY + 16 * sY - armSwingY * 1.5, skinColor, armW);

                // 昵称标签 (纸条风格)
                const textW = ctx.measureText(CFG.metadata.playerName).width;
                const nameY = headY - headR - 10 * sY; // 头顶上方

                ctx.font = `bold ${14 * sY}px "Microsoft YaHei"`; ctx.textAlign = 'center';
                // 白色底标签
                ctx.fillStyle = '#fff';
                ctx.fillRect(px - textW / 2 - 4, nameY - 14, textW + 8, 18);
                ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.strokeRect(px - textW / 2 - 4, nameY - 14, textW + 8, 18);

                ctx.fillStyle = '#333';
                ctx.fillText(CFG.metadata.playerName, px, nameY);

                ctx.restore();
            }

            // 圆角矩形辅助
            function roundRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath(); ctx.fill();
            }

            // HEX转RGB
            function hexToRGB(hex) {
                const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            }

            // ===== 圆形任务UI (中心点与消失点重合) =====
            // 绘制游戏标题
            // 构建游戏标题 (墨水风格 -> 跑道色)
            function drawGameTitle() {
                ctx.save();
                ctx.font = 'bold 36px "Microsoft YaHei"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                // 黑色水墨阴影
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillText('字跑大师', W / 2, 22);
                // 主色 (跑道颜色)
                ctx.fillStyle = '#EBE7DD';
                ctx.fillText('字跑大师', W / 2, 20);

                ctx.restore();
            }

            function drawTaskRing() {
                // Position slightly lower to accommodate larger size
                const titleBottom = 20 + 36 + 10;
                const cx = W / 2;
                const ringR = W / 4.5;
                const cy = titleBottom + ringR + 20;

                ctx.save();
                ctx.translate(cx, cy);

                // 1. 牛皮纸吊牌底座 (Kraft Paper Tag Base)
                // 阴影
                ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 8; ctx.shadowOffsetY = 4;

                // 外圈 (深棕色/牛皮纸色)
                ctx.fillStyle = '#8d6e63';
                ctx.beginPath(); ctx.arc(0, 0, ringR, 0, Math.PI * 2); ctx.fill();

                // 纹理 (简单噪点)
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for (let i = 0; i < 100; i++) {
                    const r = Math.random() * ringR;
                    const a = Math.random() * Math.PI * 2;
                    ctx.fillRect(Math.cos(a) * r, Math.sin(a) * r, 2, 2);
                }
                ctx.restore();

                // 2. 内圈 (米白纸)
                const innerR = ringR * 0.82;
                ctx.fillStyle = '#faf3e0'; // Warmer
                ctx.beginPath(); ctx.arc(0, 0, innerR, 0, Math.PI * 2); ctx.fill();

                // 内圈纹理 (增强)
                ctx.save();
                ctx.fillStyle = 'rgba(160, 140, 100, 0.08)'; // Brownish noise
                for (let i = 0; i < 300; i++) {
                    const r = Math.random() * innerR;
                    const a = Math.random() * Math.PI * 2;
                    const s = 1 + Math.random() * 2;
                    ctx.fillRect(Math.cos(a) * r, Math.sin(a) * r, s, s);
                }
                ctx.restore();

                // 纸张边缘内阴影效果
                ctx.shadowColor = 'transparent';
                ctx.strokeStyle = '#d7ccc8';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, innerR, 0, Math.PI * 2); ctx.stroke();

                // 3. 恢复外环小关卡进度动画
                const total = CFG.rules.winCorrectTotal;
                const step = (Math.PI * 2) / total;
                const startAngle = -Math.PI / 2;

                for (let i = 0; i < total; i++) {
                    const angle = startAngle + i * step;
                    const dotR = ringR * 0.92;
                    const dx = Math.cos(angle) * dotR;
                    const dy = Math.sin(angle) * dotR;

                    ctx.beginPath();
                    ctx.arc(dx, dy, 4, 0, Math.PI * 2);
                    if (i < ST.correctTotal) {
                        ctx.fillStyle = '#fff';
                        ctx.shadowColor = '#fff'; ctx.shadowBlur = 5;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    } else {
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.fill();
                    }
                }

                // 4. (已移除顶部穿孔)

                // 5. 内容展示
                // 拼音 (大号蓝色)
                ctx.fillStyle = '#2980b9';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const fontSize = Math.floor(innerR * 0.7);
                ctx.font = `bold ${fontSize}px "Microsoft YaHei"`;
                ctx.fillText(ST.currentPinyin || '--', 0, 0);

                // 进度 (下方小字)
                const progressText = `${ST.completedWordCount + 1}/${allData.length}`;
                ctx.fillStyle = '#2d3436';
                ctx.font = `bold ${Math.floor(innerR * 0.25)}px "Microsoft YaHei"`;
                ctx.fillText(progressText, 0, innerR * 0.6);

                ctx.restore();
            }

            // ===== 物体系统 =====
            function spawnObject() {
                if (ST.paused || ST.gameOver || !ST.running) return;
                const diff = getDifficulty();
                let r = Math.random();
                let type, word = '', pinyin = '';

                // v2.6: 正确项生成保障 — 确保关卡内能出现足够的正确项
                const remaining = CFG.rules.levelTime - ST.levelTime;
                const needed = CFG.rules.winCorrectTotal - ST.correctTotal;
                if (needed > 0 && remaining > 0) {
                    const avgInterval = (CFG.difficulty.intervalStart + CFG.difficulty.intervalEnd) / 2;
                    const estimatedSpawns = remaining * 1000 / avgInterval;
                    const pCorrect = diff.pCorrect || (1 - diff.pObstacle - diff.pWrong);
                    if (estimatedSpawns * pCorrect < needed * 1.8) {
                        r = 1.0; // 强制落入 correct 区间
                    }
                }

                // 确定物体类型
                const pObs = diff.pObstacle;
                const pWrong = diff.pWrong;
                // pCorrect is the rest

                if (r < pObs) {
                    type = 'obstacle';
                } else if (r < pObs + pWrong) {
                    type = 'wrong';
                    // v2.8: 严格排除同音字 — 干扰项不能是任何与当前拼音相同的汉字
                    const correctWords = allData.filter(d => d.pinyin === ST.currentPinyin).map(d => d.word);
                    const pool = allData.filter(d => d.pinyin !== ST.currentPinyin && !correctWords.includes(d.word));
                    if (pool.length > 0) { const item = pool[Math.floor(Math.random() * pool.length)]; word = item.word; pinyin = item.pinyin; }
                    else { type = 'obstacle'; } // fallback
                } else {
                    type = 'correct';
                    // v2.8: 只生成本关的唯一正确汉字
                    if (ST.currentCorrectWord) {
                        word = ST.currentCorrectWord;
                        pinyin = ST.currentPinyin;
                    } else {
                        type = 'obstacle'; // fallback
                    }
                }

                // 选择跑道（不在同一跑道放相同干扰项）
                let track = Math.floor(Math.random() * 3);
                const existingOnTrack = ST.objects.filter(o => o.track === track && o.y < VP.y + 100);
                if (existingOnTrack.length > 0) track = (track + 1) % 3;

                ST.objects.push({
                    type, track, y: VP.y, word, pinyin,
                    alive: true, scale: 0.08
                });
            }

            function updateObjects() {
                const diff = getDifficulty();
                const py = H * CFG.physics.playerY;

                for (let i = ST.objects.length - 1; i >= 0; i--) {
                    const o = ST.objects[i];
                    // v2.8: 跑动时速度加倍
                    const speed = diff.speed * ST.runSpeedMultiplier;
                    o.y += speed;
                    o.scale = perspScale(o.y);

                    // 碰撞检测
                    if (o.alive && o.y > py - 40 && o.y < py + 20) {
                        const ox = trackX(o.track, o.y);
                        const px = trackX(ST.trackIndex, py);
                        const dist = Math.abs(ox - px);

                        if (dist < 30 * o.scale) {
                            // 玩家在跳跃中 → 跳过
                            if (ST.isJumping && ST.playerJump > 30) {
                                if (o.type === 'obstacle') {
                                    ST.score += CFG.scoring.dodgeObstacle;
                                }
                                // 跳过不触发碰撞
                            } else {
                                handleCollision(o);
                            }
                            o.alive = false;
                        }
                    }

                    // 移出屏幕
                    if (o.y > H + 50) {
                        ST.objects.splice(i, 1);
                    }
                }
            }

            function drawObjects() {
                ST.objects.forEach(o => {
                    if (!o.alive) return;
                    const x = trackX(o.track, o.y);
                    let s = o.scale;

                    if (o.type === 'obstacle') s = s * CFG.physics.obstacleScale;

                    ctx.save();
                    ctx.translate(x, o.y);

                    if (o.type === 'obstacle') {
                        // v3.3: 厚牛皮纸箱板立牌 (Thick Corrugated Cardboard)
                        const w = 50 * s;
                        const h = 40 * s;

                        // 阴影
                        ctx.shadowColor = 'rgba(0,0,0,0.4)'; ctx.shadowOffsetY = 5 * s; ctx.shadowBlur = 6 * s;

                        // 1. 立牌底座 (深色硬纸板)
                        ctx.fillStyle = '#5d4037';
                        ctx.fillRect(-w / 2, h / 2 - 4 * s, w, 6 * s);

                        // 2. 剪纸主体 (波浪形/火焰形)
                        ctx.beginPath();
                        const points = [];
                        const steps = 8;
                        const stepW = w / steps;

                        // 左下角
                        points.push({ x: -w / 2, y: h / 2 - 4 * s });

                        // 上边缘波浪 (更圆润)
                        for (let i = 0; i <= steps; i++) {
                            const px = -w / 2 + i * stepW;
                            const py = -h / 2 + Math.sin(i * 0.8 + o.y * 0.1) * 8 * s + (i % 2 == 0 ? 2 * s : -2 * s);
                            points.push({ x: px, y: py });
                        }

                        // 右下角
                        points.push({ x: w / 2, y: h / 2 - 4 * s });

                        // 闭合并填充
                        ctx.moveTo(points[0].x, points[0].y);
                        for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                        ctx.closePath();

                        // 填充: 牛皮纸渐变
                        const grad = ctx.createLinearGradient(0, -h, 0, h);
                        grad.addColorStop(0, '#e67e22'); // 亮橙
                        grad.addColorStop(1, '#d35400'); // 深橙
                        ctx.fillStyle = grad;
                        ctx.fill();

                        // 3. 增加厚度 (侧面 3D)
                        ctx.shadowColor = 'transparent';
                        ctx.fillStyle = '#8d6e63'; // 侧面深褐色
                        ctx.beginPath();
                        const thickness = 6 * s;
                        for (let i = 1; i < points.length; i++) {
                            ctx.moveTo(points[i - 1].x, points[i - 1].y);
                            ctx.lineTo(points[i].x, points[i].y);
                            ctx.lineTo(points[i].x + thickness, points[i].y + thickness * 0.5);
                            ctx.lineTo(points[i - 1].x + thickness, points[i - 1].y + thickness * 0.5);
                        }
                        ctx.fill();

                        // 4. 瓦楞纸纹理 (内部纹理)
                        ctx.strokeStyle = 'rgba(0,0,0,0.15)'; // 深色压痕
                        ctx.lineWidth = 2 * s;
                        ctx.beginPath();
                        // 竖向条纹
                        const stripeCount = 6;
                        const stripeGap = w / stripeCount;
                        for (let i = 1; i < stripeCount; i++) {
                            const sx = -w / 2 + i * stripeGap;
                            if (sx < w / 2 - 5 * s) { // 简单裁剪
                                ctx.moveTo(sx, -h / 2 + 10 * s);
                                ctx.lineTo(sx, h / 2 - 6 * s);
                            }
                        }
                        ctx.stroke();

                        // 材质噪点
                        ctx.fillStyle = 'rgba(255,255,255,0.1)';
                        for (let k = 0; k < 20; k++) {
                            ctx.fillRect(-w / 2 + Math.random() * w, -h / 2 + Math.random() * h, 2, 2);
                        }

                        // 警告标识 (喷漆/印章效果)
                        const triSz = 12 * s;
                        const triY = 2 * s;
                        ctx.fillStyle = 'rgba(50, 50, 50, 0.8)'; // 黑墨水
                        ctx.beginPath();
                        ctx.moveTo(0, triY - triSz);
                        ctx.lineTo(-triSz * 0.8, triY + triSz * 0.6);
                        ctx.lineTo(triSz * 0.8, triY + triSz * 0.6);
                        ctx.fill();

                        // 感叹号
                        ctx.fillStyle = '#e67e22'; // 镂空
                        ctx.font = `bold ${14 * s}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText('!', 0, triY + triSz * 0.4);

                    } else {
                        // v3.2: 统一不规则深黄色方形便签 (Irregular Dark Yellow Square)
                        const sz = 36 * s;

                        ctx.shadowColor = 'rgba(0,0,0,0.3)';
                        ctx.shadowOffsetY = 4 * s;
                        ctx.shadowBlur = 3 * s;

                        // 深黄色
                        ctx.fillStyle = '#f1c40f'; // Vivid Yellow/Orange-Yellow

                        // 稍微旋转
                        const rot = ((o.y * 100) % 10 - 5) * 0.02;
                        ctx.rotate(rot);

                        const w = sz * 1.3;
                        const h = sz * 1.3;

                        const points = [
                            { x: -w / 2, y: -h / 2 },
                            { x: w / 2, y: -h / 2 },
                            { x: w / 2, y: h / 2 },
                            { x: -w / 2, y: h / 2 },
                            { x: -w / 2, y: -h / 2 }
                        ];
                        drawRoughPath(ctx, points, true);
                        ctx.fill();

                        // 纸张纹理 (增加噪点)
                        ctx.fillStyle = 'rgba(0,0,0,0.05)';
                        for (let k = 0; k < 10; k++) {
                            ctx.fillRect(-w / 2 + Math.random() * w, -h / 2 + Math.random() * h, 2, 2);
                        }

                        ctx.shadowColor = 'transparent';
                        ctx.strokeStyle = '#d4ac0d'; // Darker border
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // 汉字 (墨水风)
                        ctx.fillStyle = '#2d3436';
                        ctx.font = `bold ${24 * s}px "Microsoft YaHei"`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(o.word, 0, 0);

                        // 拼音 (已移除)
                    }
                    ctx.restore();
                });
            }

            // ===== 碰撞处理 =====
            function handleCollision(o) {
                // v2.8.6: 通关动画期间无敌
                if (ST.isCompletingLevel && o.type !== 'correct') return;
                if (CFG.ui.isInvincible && o.type !== 'correct') return;

                if (o.type === 'obstacle') {
                    ST.lives -= CFG.rules.obstacleDamage;
                    SFX.hit();
                    ST.combo = 0; ST.wrongStreak = 0;
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff3c3c', 15);
                } else if (o.type === 'wrong') {
                    ST.lives -= CFG.rules.wrongDamage;
                    SFX.wrong();
                    ST.combo = 0;
                    ST.wrongStreak++;
                    ST.correctStreak = 0;
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff6b6b', 10);
                } else if (o.type === 'correct') {
                    ST.combo++;
                    if (ST.combo > ST.maxCombo) ST.maxCombo = ST.combo;
                    const multiplier = Math.min(ST.combo, CFG.scoring.comboMax);
                    ST.score += CFG.scoring.correctBase * multiplier;
                    ST.correctTotal++;
                    ST.correctStreak++;
                    ST.wrongStreak = 0;
                    SFX.correct({ pinyin: ST.currentPinyin, word: o.word }); // v2.8: 传入word用于播放汉字读音
                    spawnParticles(trackX(o.track, o.y), o.y, '#00ffcc', 25);
                    spawnParticles(trackX(o.track, o.y), o.y, '#ffd700', 15);
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff69b4', 10);
                }

                // v2.8.6: 每次连击重置显示时间
                if (ST.combo >= 2) ST.comboDisplayTimer = 0.8; // 0.8秒后消失

                updateHUD();
                checkLevelState();
            }

            // ===== 关卡检查 =====
            function checkLevelState() {
                if (ST.lives <= 0) {
                    endGame(); return;
                }
                // 连击4个错误 → 失败
                if (ST.wrongStreak >= CFG.rules.failWrongStreak) {
                    endGame(); return;
                }
                // 累计9个正确 或 连续4个正确 → 过关
                // v2.8.6: 延迟通关逻辑
                const isWin = ST.correctTotal >= CFG.rules.winCorrectTotal || ST.correctStreak >= CFG.rules.winCorrectStreak;

                if (isWin && !ST.isCompletingLevel) {
                    // 开始通关流程：光环动画 -> 延迟 -> 弹窗
                    ST.isCompletingLevel = true;
                    ST.ringCompleteAnim = 1.0; // 触发外环闪烁动画
                    SFX.levelUp(); // 播放音效

                    // 1.5秒后显示结算界面
                    setTimeout(() => {
                        clearLevel();
                    }, 1500);
                }
            }

            function clearLevel() {
                ST.paused = true;
                ST.totalLevelsCleared++;
                ST.streakLevels++;
                // ST.ringCompleteAnim = 1.0; // 移至 checkLevelState 提前触发

                // 积分奖励
                const remaining = CFG.rules.levelTime - ST.levelTime;
                ST.score += CFG.scoring.levelClear + Math.floor(remaining) * CFG.scoring.timeBonus;
                ST.score += ST.streakLevels * CFG.scoring.streakBonus;
                SFX.levelUp();

                // v2.8: 累加已完成的字数
                ST.completedWordCount++;

                // v2.8.2: 修正通关简报显示
                const lcInfo = document.getElementById('lc-info');
                const justPassedLevel = ST.levelIndex + 1; // 刚通过的是第X关

                // 通关标题
                document.querySelector('#level-clear h2').textContent = `第${justPassedLevel}关 通过！`;

                // v2.8: 任务简报只显示本关的正确汉字
                lcInfo.innerHTML = `任务：${ST.currentPinyin} → ${ST.currentCorrectWord}<br>正确：${ST.correctTotal}个 | 连击：${ST.maxCombo}<br>得分：${ST.score}分<br>等级：${getLevel(ST.score).rank}`;

                document.getElementById('level-clear').style.display = 'flex';
            }

            function nextLevel() {
                document.getElementById('level-clear').style.display = 'none';
                ST.levelIndex++;
                if (ST.levelIndex >= pinyinList.length) {
                    // 所有关卡完成
                    endGame(true); return;
                }
                startLevel();
            }

            function startLevel() {
                ST.levelTime = 0; ST.correctTotal = 0; ST.correctStreak = 0; ST.wrongStreak = 0; ST.combo = 0; ST.maxCombo = 0;
                ST.comboDisplayTimer = 0; // v2.8.6: 连击显示计时器
                ST.isCompletingLevel = false; // v2.8.6: 重置通关状态
                ST.objects = []; ST.particles = [];
                ST.appearedCorrectWords.clear(); // v2.5: 重置同音字记录
                ST.currentPinyin = pinyinList[ST.levelIndex];
                const matches = allData.filter(d => d.pinyin === ST.currentPinyin);
                // v2.8: 为本关选择唯一的正确汉字
                if (matches.length > 0) {
                    const selectedItem = matches[Math.floor(Math.random() * matches.length)];
                    ST.currentCorrectWord = selectedItem.word;
                    ST.currentWord = selectedItem.word; // 只显示本关的正确汉字
                } else {
                    ST.currentCorrectWord = '';
                    ST.currentWord = ST.currentPinyin;
                }
                ST.paused = false;
                ST.levelTimer = 0;
                updateHUD();
                // v2.8: 任务提示音 - 播放汉字读音而非拼音
                setTimeout(() => speakWord(ST.currentCorrectWord || ST.currentPinyin), 300);
            }

            function endGame(allClear) {
                ST.gameOver = true; ST.running = false;
                if (!allClear) ST.failedLevelIndex = ST.levelIndex; // v2.8: 记录失败的关卡索引
                stopBGM();
                if (!allClear) SFX.gameOver(); else SFX.levelUp();
                const stats = document.getElementById('go-stats');
                const title = document.querySelector('#game-over h2');
                title.textContent = allClear ? '🎉 全部通关！' : '游戏结束';
                title.style.color = allClear ? '#00ffcc' : '#ff6b6b';
                // v2.8.1: 修复游戏结束统计信息，显示正确的进度
                const currentProgress = `${ST.completedWordCount}/${allData.length}`; // 当前已完成的字数
                const currentLevel = `第${ST.levelIndex + 1}关`; // 当前关卡
                stats.innerHTML = `当前进度：${currentProgress}<br>当前小关：${currentLevel}<br>总得分：${ST.score}<br>最高连击：${ST.maxCombo}<br>等级：${getLevel(ST.score).rank}`;
                document.getElementById('game-over').style.display = 'flex';
            }

            function restartGame() {
                document.getElementById('game-over').style.display = 'none';
                ST.lives = CFG.rules.initLives; ST.score = 0; ST.combo = 0; ST.maxCombo = 0;
                // v2.8: 从失败的关卡重新开始，保持进度
                if (ST.failedLevelIndex >= 0) {
                    ST.levelIndex = ST.failedLevelIndex;
                    // completedWordCount 保持不变，显示当前进度
                } else {
                    ST.levelIndex = 0;
                    ST.completedWordCount = 0;
                }
                ST.totalLevelsCleared = 0; ST.streakLevels = 0;
                ST.objects = []; ST.particles = []; ST.roadLines = [];
                ST.appearedCorrectWords.clear();
                ST.lastTime = 0; // v2.6: 重置时间戳，修复 dt 异常
                ST.gameOver = false; ST.running = true; ST.paused = false;
                if (ST.failedLevelIndex < 0) shuffleArray(pinyinList); // 只在全新开始时打乱
                startLevel();
                startBGM();
            }

            // ===== HUD 更新 =====
            function updateHUD() {
                // 分数 & 生命
                // 生命值 (支持半心)
                let hearts = '';
                const full = Math.floor(ST.lives);
                const half = ST.lives % 1 >= 0.5 ? 1 : 0;
                const empty = Math.max(0, CFG.rules.initLives - full - half);
                for (let i = 0; i < full; i++) hearts += '❤️';
                if (half) hearts += '💔';
                for (let i = 0; i < empty; i++) hearts += '🖤';
                document.getElementById('hud-hearts').textContent = hearts;

                // 时间
                const remaining = Math.max(0, Math.ceil(CFG.rules.levelTime - ST.levelTime));
                document.getElementById('hud-timer').textContent = remaining + 's';
                document.getElementById('hud-timer').style.color = remaining <= 10 ? '#ff3c3c' : '#ff6b6b';

                // 任务
                document.getElementById('hud-task').textContent = `任务：${ST.currentPinyin}`;

                // 分数
                document.getElementById('hud-score').textContent = ST.score + '分';

                // 等级
                const lv = getLevel(ST.score);
                const lvIdx = CFG.levels.indexOf(lv) + 1;
                document.getElementById('hud-level').textContent = `Lv.${lvIdx} ${lv.rank}`;

                // v2.8.6: 连击提示优化（带动画）
                const comboEl = document.getElementById('hud-combo');
                if (ST.combo >= 2 && ST.comboDisplayTimer > 0) {
                    comboEl.textContent = `🔥 ${ST.combo}连击！`;
                    comboEl.classList.remove('fade-out');
                    comboEl.style.opacity = '1';
                } else {
                    comboEl.classList.add('fade-out');
                    // opacity由CSS处理
                }
            }

            // ===== 物体生成计时器 =====
            let spawnTimer = 0;
            function updateSpawner(dt) {
                const diff = getDifficulty();
                spawnTimer += dt * 1000;
                if (spawnTimer >= diff.interval) {
                    spawnObject();
                    spawnTimer = 0;
                }
            }

            // ===== 主循环 =====
            function gameLoop(timestamp) {
                requestAnimationFrame(gameLoop);
                if (!ST.running) return;
                if (ST.lastTime === 0) ST.lastTime = timestamp;
                const dt = Math.min((timestamp - ST.lastTime) / 1000, 0.05);
                ST.lastTime = timestamp; ST.frameCount++;
                if (ST.paused) return;

                // 关卡计时
                // 关卡计时
                // v2.8.6: 通关动画期间停止计时
                if (!ST.isCompletingLevel) {
                    ST.levelTime += dt;
                    if (ST.levelTime >= CFG.rules.levelTime) {
                        endGame(); return;
                    }
                }

                // v2.8.6: 更新连击计时器
                if (ST.comboDisplayTimer > 0) {
                    ST.comboDisplayTimer -= dt;
                    if (ST.comboDisplayTimer <= 0) updateHUD(); // 触发消失动画
                }

                // v2.8.3: 检测长按并更新跑动状态
                updateRunningState();

                // v2.8: 角色动画（跑动比走动快）
                const animSpeed = ST.isRunning ? 0.2 : 0.12;
                ST.playerAnim += animSpeed;

                // 跳跃物理
                // 跳跃物理 update
                if (ST.isJumping) {
                    ST.playerJump += ST.jumpVy * dt;
                    ST.jumpVy -= CFG.physics.gravity * dt;

                    // 落地检测
                    if (ST.playerJump <= 0) {
                        ST.playerJump = 0;
                        ST.isJumping = false;
                        // 落地特效
                        SFX.hit(); // 或者单独的 land 音效
                        spawnParticles(trackX(ST.trackIndex, H * CFG.physics.playerY), H * CFG.physics.playerY, '#fff', 5);
                        ST.landingScale = 0.6; // 触发挤压动画
                    }
                }

                // 更新
                updateRoadLines();
                updateSpawner(dt);
                updateObjects();
                updateParticles();
                updateHUD();

                // 绘制
                ctx.clearRect(0, 0, W, H);
                drawTrack();
                drawGameTitle();
                drawJumpTrajectory();
                drawObjects();
                drawTaskRing();
                drawPlayer();
                drawParticles();
            }

            // v2.8.3: 跳跃 (物理驱动，支持原地跳和跑动跳)
            function jumpPlayer(isRunJump = false) {
                if (ST.isJumping || !ST.running || ST.paused) return;
                ST.isJumping = true;
                // 跑动中跳跃力度更大
                ST.jumpVy = isRunJump ? CFG.physics.jumpForce * 1.3 : CFG.physics.jumpForce;
                SFX.jump();
            }

            // ===== 车道切换 =====
            function movePlayer(dir) {
                if (!ST.running || ST.paused) return;
                ST.trackIndex = Math.max(0, Math.min(2, ST.trackIndex + dir));
            }

            // ===== 暂停 =====
            function togglePause() {
                if (!ST.running || ST.gameOver) return;
                ST.paused = !ST.paused;
                document.getElementById('hud-task').textContent = ST.paused ? '⏸ 已暂停' : `寻找拼音：${ST.currentPinyin}`;
            }

            // v2.8.3: 按键状态跟踪（用于单击/长按/双击检测）
            let lastUpKeyTime = 0;
            let upKeyPressed = false;
            let upKeyPressTime = 0;
            const LONG_PRESS_THRESHOLD = 200; // 长按阈值（毫秒）
            const DOUBLE_CLICK_THRESHOLD = 300; // 双击阈值（毫秒）

            // ===== 键盘输入 =====
            document.addEventListener('keydown', e => {
                if (e.code === 'ArrowUp' && !upKeyPressed) {
                    upKeyPressed = true;
                    upKeyPressTime = Date.now();
                    e.preventDefault();
                } else if (e.code === 'ArrowLeft') {
                    movePlayer(-1); e.preventDefault();
                } else if (e.code === 'ArrowRight') {
                    movePlayer(1); e.preventDefault();
                } else if (e.code === 'Space') {
                    togglePause(); e.preventDefault();
                }
            });

            document.addEventListener('keyup', e => {
                if (e.code === 'ArrowUp' && upKeyPressed) {
                    const now = Date.now();
                    const pressDuration = now - upKeyPressTime;
                    upKeyPressed = false;

                    // 判断是否为长按（跑动）
                    if (pressDuration >= LONG_PRESS_THRESHOLD) {
                        // 长按结束，停止跑动
                        ST.isRunning = false;
                        ST.runSpeedMultiplier = 1.0;
                    } else {
                        // 快速单击
                        // 检查是否为双击（在跑动状态下的双击跳跃）
                        if (ST.isRunning && now - lastUpKeyTime < DOUBLE_CLICK_THRESHOLD) {
                            // 跑动中双击 = 跑动跳跃
                            jumpPlayer(true);
                            lastUpKeyTime = 0;
                        } else {
                            // 单击 = 原地跳跃
                            jumpPlayer(false);
                            lastUpKeyTime = now;
                        }
                    }
                }
            });

            // v2.8.3: 检测长按并触发跑动
            function updateRunningState() {
                if (upKeyPressed && !ST.isRunning) {
                    const pressDuration = Date.now() - upKeyPressTime;
                    if (pressDuration >= LONG_PRESS_THRESHOLD) {
                        ST.isRunning = true;
                        ST.runSpeedMultiplier = 2.0;
                    }
                }
                // 更新跑动动画
                if (ST.isRunning && !ST.paused) {
                    ST.runAnimPhase = (ST.runAnimPhase + 0.2) % (Math.PI * 2);
                }
            }

            // ===== 触摸手势 =====
            let touchStartX = 0, touchStartY = 0, touchStartTime = 0, lastTapTime = 0, lastUpTapTime = 0;
            document.addEventListener('touchstart', e => {
                const t = e.touches[0]; touchStartX = t.clientX; touchStartY = t.clientY; touchStartTime = Date.now();
                e.preventDefault();
            }, { passive: false });
            document.addEventListener('touchend', e => {
                const t = e.changedTouches[0];
                const dx = t.clientX - touchStartX, dy = t.clientY - touchStartY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const elapsed = Date.now() - touchStartTime;

                if (dist < 20 && elapsed < 300) {
                    // 点击 → 检查双击
                    const now = Date.now();
                    if (now - lastTapTime < 350) { togglePause(); lastTapTime = 0; }
                    else lastTapTime = now;
                } else if (dist > 30) {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        dx < 0 ? movePlayer(-1) : movePlayer(1);
                    } else if (dy < -30) {
                        // v2.8: 向上滑动 - 检测双击跳跃 vs 单击跑动
                        const now = Date.now();
                        if (now - lastUpTapTime < 300) {
                            jumpPlayer();
                            lastUpTapTime = 0;
                        } else {
                            ST.isRunning = true;
                            ST.runSpeedMultiplier = 2.0;
                            lastUpTapTime = now;
                            // 0.5秒后自动恢复走动
                            setTimeout(() => {
                                ST.isRunning = false;
                                ST.runSpeedMultiplier = 1.0;
                            }, 500);
                        }
                    }
                }
                e.preventDefault();
            }, { passive: false });


            // ===== 启动 =====
            // 页面加载时加载保存的配置
            loadConfig();
            // v2.9.1: 同步 ST.lives（loadConfig 在 ST 初始化之后执行，需手动同步）
            ST.lives = CFG.rules.initLives;

            document.getElementById('start-btn').onclick = () => {
                const ss = document.getElementById('start-screen');
                ss.style.opacity = '0';
                setTimeout(() => ss.remove(), 600);
                ensureAudio();
                // 预热 TTS
                const v = new SpeechSynthesisUtterance(''); v.volume = 0; window.speechSynthesis.speak(v);
                startBGM();
                ST.running = true;
                startLevel();
                requestAnimationFrame(gameLoop);
            };

            document.getElementById('go-restart').onclick = restartGame;
            document.getElementById('lc-next').onclick = nextLevel;

        })();
    </script>
</body>

</html>