<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>å­—è·‘å¤§å¸ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #2d3436;
            /* Deep Grey Background */
            font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
            touch-action: none;
            user-select: none
        }

        #wrap {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative
        }

        canvas {
            display: block;
            image-rendering: pixelated
        }

        /* HUD: Top Status Bar - All on Top Right */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Level & Score -> Top Left (stacked vertically) */
        #hud .group-left {
            position: absolute;
            top: 12px;
            left: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: flex-start;
        }

        /* Hearts -> Top Right */
        #hud .group-right {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 6px;
            align-items: center;
        }

        /* Hide the container row if it exists */
        #hud .row.top-bar {
            display: block;
        }

        /* Yellow Sticky Note Style with Lines */
        .hud-note {
            background-color: #ffeaa7;
            background-image: repeating-linear-gradient(transparent, transparent 19px, #ccc 20px);
            color: #2d3436;
            padding: 6px 12px;
            border-radius: 2px;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            font-weight: bold;
            font-size: 14px;
            text-shadow: none;
            border: 1px solid #e0cba0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 60px;
        }

        /* Specific rotations for natural feel */
        .hud-note:nth-child(odd) {
            transform: rotate(-1deg);
        }

        .hud-note:nth-child(even) {
            transform: rotate(1deg);
        }

        #hud .task {
            display: none
        }

        #hud-hearts {
            /* Hearts can be on white or yellow, user asked for yellow note background for status bar */
            color: #d63031;
        }

        #hud-score {
            color: #d63031;
            font-family: "Comic Sans MS", "Marker Felt", sans-serif;
            font-size: 20px;
        }

        #hud-level {
            font-size: 14px;
            color: #636e72;
        }

        #hud-timer {
            /* Timer is now drawn on canvas inside the task ring */
            display: none !important;
        }

        #hud .combo {
            position: absolute;
            top: 42%;
            /* Middle of runway */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #fdcb6e;
            text-shadow: 2px 2px 0 #d63031;
            font-weight: bold;
            opacity: 0;
            transition: opacity .1s, transform .1s;
            pointer-events: none;
            z-index: 20;
            white-space: nowrap;
        }

        #hud .combo.fade-out {
            opacity: 0 !important;
            transform: translate(-50%, -80%);
        }

        /* Phase Transition Popup */
        #phase-transition {
            position: fixed;
            inset: 0;
            background-color: rgba(45, 52, 54, 0.95);
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            backdrop-filter: blur(5px);
        }

        #phase-transition h2 {
            font-size: 36px;
            color: #00ffcc;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.5);
            margin-bottom: 16px;
        }

        #phase-transition .info {
            font-size: 20px;
            color: #dfe6e9;
            line-height: 2;
            text-align: center;
            margin-bottom: 40px;
        }

        #phase-transition button {
            padding: 12px 40px;
            font-size: 24px;
            background-color: #ffeaa7;
            background-image: repeating-linear-gradient(transparent, transparent 19px, #ccc 20px);
            border: 1px solid #e0cba0;
            border-radius: 2px;
            cursor: pointer;
            font-weight: bold;
            color: #2d3436;
            box-shadow: 4px 4px 6px rgba(0, 0, 0, 0.4);
            transform: rotate(-1deg);
            transition: transform 0.2s;
            font-family: "Microsoft YaHei", sans-serif;
        }

        #phase-transition button:hover {
            transform: scale(1.05) rotate(0deg);
        }

        #start-screen {
            position: fixed;
            inset: 0;
            background-color: #2d3436;
            background-image: radial-gradient(circle at center, rgba(50, 50, 50, 0.5) 0%, rgba(0, 0, 0, 0.5) 100%);
            /* Pattern would be better, but simple dark grey works with the theme */
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: "Microsoft YaHei", sans-serif
        }

        #start-screen h1 {
            font-size: 64px;
            color: #EBE7DD;
            /* Runway Color */
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
            margin-bottom: 8px;
            letter-spacing: 6px;
            font-weight: bold;
        }

        #start-screen .sub {
            color: #b2bec3;
            font-size: 14px;
            margin-bottom: 60px
        }

        #start-screen button {
            padding: 16px 56px;
            font-size: 24px;
            /* Sticky Note Style */
            background-color: #ffeaa7;
            background-image: repeating-linear-gradient(transparent, transparent 19px, #ccc 20px);
            border: 1px solid #e0cba0;
            border-radius: 2px;
            cursor: pointer;
            font-weight: bold;
            color: #2d3436;
            box-shadow: 4px 4px 6px rgba(0, 0, 0, 0.4);
            transition: transform .2s, box-shadow .2s;
            transform: rotate(-2deg);
            font-family: "Microsoft YaHei", sans-serif;
        }

        #start-screen button:hover {
            transform: scale(1.05) rotate(-1deg);
            box-shadow: 6px 6px 10px rgba(0, 0, 0, 0.5)
        }


        #game-over {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .85);
            z-index: 80;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff
        }

        #game-over h2 {
            font-size: 36px;
            color: #ff6b6b;
            margin-bottom: 16px
        }

        #game-over .stats {
            font-size: 16px;
            line-height: 2;
            text-align: center;
            margin-bottom: 24px
        }

        #game-over button {
            padding: 14px 48px;
            font-size: 18px;
            background: #00ffcc;
            color: #003d33;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold
        }

        #level-clear {
            position: fixed;
            inset: 0;
            background-color: rgba(45, 52, 54, 0.95);
            /* Dark Grey translucent */
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            backdrop-filter: blur(5px);
        }

        #level-clear h2 {
            font-size: 48px;
            color: #fdcb6e;
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }

        #level-clear .info {
            font-size: 24px;
            color: #dfe6e9;
            line-height: 2;
            text-align: center;
            margin-bottom: 40px;
        }

        #level-clear button {
            padding: 12px 40px;
            font-size: 24px;
            /* Sticky Note Style */
            background-color: #ffeaa7;
            background-image: repeating-linear-gradient(transparent, transparent 19px, #ccc 20px);
            border: 1px solid #e0cba0;
            border-radius: 2px;
            cursor: pointer;
            font-weight: bold;
            color: #2d3436;
            box-shadow: 4px 4px 6px rgba(0, 0, 0, 0.4);
            transform: rotate(1deg);
            transition: transform 0.2s;
            font-family: "Microsoft YaHei", sans-serif;
        }

        #level-clear button:hover {
            transform: scale(1.05) rotate(0deg);
        }
    </style>
</head>

<body>
    <div id="start-screen">
        <h1>å­—è·‘å¤§å¸ˆ</h1>
        <div class="sub">Word Runner Master</div>
        <button id="start-btn">å¼€å§‹æ¸¸æˆ</button>
    </div>
    <div id="wrap">
        <canvas id="gc"></canvas>
        <div id="hud">
            <div class="row top-bar">
                <div class="group-left">
                    <span class="hud-note" id="hud-level">Lv.1 è¯†å­—æ–°å…µ</span>
                    <span class="hud-note" id="hud-score">0åˆ†</span>
                </div>
                <div class="group-right">
                    <span class="hud-note" id="hud-hearts">â¤ï¸â¤ï¸â¤ï¸</span>
                </div>
            </div>
            <span id="hud-timer" style="display:none">40s</span>
            <div class="task" id="hud-task">å‡†å¤‡èµ·è·‘</div>
            <div style="text-align:center"><span id="hud-combo" class="combo"></span></div>
        </div>
    </div>

    <div id="game-over">
        <h2>æ¸¸æˆç»“æŸ</h2>
        <div class="stats" id="go-stats"></div><button id="go-restart">å†æ¥ä¸€å±€</button>
    </div>
    <div id="level-clear">
        <h2 id="lc-title">è¿‡å…³ï¼</h2>
        <div class="info" id="lc-info"></div><button id="lc-next">ä¸‹ä¸€å…³</button>
    </div>

    <div id="phase-transition">
        <h2>ğŸ‰ éŸ³æ‰¾å­—å…³å¡å·²å®Œæˆï¼</h2>
        <div class="info">æ¥ä¸‹æ¥è¿›å…¥â€œå­—æ‰¾éŸ³â€å…³å¡<br>ä»»åŠ¡åŒºå°†æ˜¾ç¤ºæ±‰å­—ï¼Œè·‘é“ä¸Šå‡ºç°æ‹¼éŸ³</div>
        <button id="phase-next-btn">è¿›å…¥å­—æ‰¾éŸ³å…³å¡</button>
    </div>

    <script>
        // ========== é…ç½®å—ï¼ˆç”± workbench.html æ³¨å…¥ï¼‰==========
        window.WRM_CONFIG = {
            metadata: { version: "3.5.0", unitTitle: "å­—è·‘å¤§å¸ˆ", playerName: "è´è´" },
            rules: {
                levelTime: 40,
                winCorrectTotal: 9,
                winCorrectStreak: 4,
                failWrongStreak: 4,
                initLives: 3,
                obstacleDamage: 1,
                wrongDamage: 0.5
            },
            difficulty: {
                speedStart: 2, speedEnd: 6,
                intervalStart: 2000, intervalEnd: 800,
                obstacleStart: 0.10, obstacleEnd: 0.40,
                wrongStart: 0.20, wrongEnd: 0.45,
                correctStart: 0.70, correctEnd: 0.15
            },
            scoring: {
                correctBase: 10, comboMax: 5,
                hitDistractor: -3, hitObstacle: -5,
                comboRewards: { 2: 20, 3: 30, 4: 40, 5: 50 }
            },
            character: {
                nickname: "è´è´",
                grades: [
                    { name: "ç«¥ç”Ÿ", score: 0 },
                    { name: "ç§€æ‰", score: 100 },
                    { name: "è´¡ç”Ÿ", score: 200 },
                    { name: "ä¸¾äºº", score: 300 },
                    { name: "è§£å…ƒ", score: 400 },
                    { name: "è´¡å£«", score: 500 },
                    { name: "ä¼šå…ƒ", score: 600 },
                    { name: "è¿›å£«", score: 700 },
                    { name: "æ¢èŠ±", score: 800 },
                    { name: "æ¦œçœ¼", score: 900 },
                    { name: "çŠ¶å…ƒ", score: 1000 }
                ]
            },
            // levels æ•°ç»„å·²ç§»é™¤ï¼Œç°åœ¨é€šè¿‡ CFG.character.grades åŠ¨æ€è·å–
            physics: {
                tracksX: [0.166666, 0.5, 0.833333], // v2.9.2: çœŸæ­£ä¸‰ç­‰åˆ†è·‘é“ï¼ˆ1/6, 1/2, 5/6ï¼‰
                playerY: 0.90, // ä¸‹ç§»è‡³ 90%
                gravity: 2000,
                jumpForce: 750,
                objScaleStart: 0.08, // ç‰©ä½“è¿œç«¯ç¼©æ”¾
                objScaleEnd: 1.0,     // ç‰©ä½“è¿‘ç«¯ç¼©æ”¾
                playerScale: 1.5,     // è§’è‰²å›ºå®šç¼©æ”¾
                obstacleScale: 1.0    // éšœç¢ç‰©é¢å¤–ç¼©æ”¾
            },
            levelDesign: {
                levelName: "éŸ³æ‰¾å­—",                    // å…³å¡åç§°
                taskSource: "pinyin",                    // ä»»åŠ¡åŒºæ•°æ®æ¥æº: pinyin | word
                correctSource: "word",                   // æ­£ç¡®é¡¹æ•°æ®æ¥æº: word
                wrongSource: "word_exclude_homophone",   // å¹²æ‰°é¡¹æ•°æ®æ¥æº: word | word_exclude_homophone
                polyphoneRule: "use_data_pinyin",        // å¤šéŸ³å­—è§„åˆ™: use_data_pinyin | auto
                homophoneRule: "exclusive"               // åŒéŸ³å­—è§„åˆ™: exclusive | allow_both
            },
            ui: { themeColor: "#00ffcc", isInvincible: false },
            dataSource: {
                offlineData: [
                    { "word": "æ½®", "pinyin": "chÃ¡o" }, { "word": "ç›", "pinyin": "yÃ¡n" }, { "word": "è–„", "pinyin": "bÃ³" },
                    { "word": "å±¹", "pinyin": "yÃ¬" }, { "word": "æ˜‚", "pinyin": "Ã¡ng" }, { "word": "é¼", "pinyin": "dÇng" },
                    { "word": "æ²¸", "pinyin": "fÃ¨i" }, { "word": "æ®", "pinyin": "jÃ¹" }, { "word": "å ¤", "pinyin": "dÄ«" },
                    { "word": "é˜”", "pinyin": "kuÃ²" }, { "word": "ç›¼", "pinyin": "pÃ n" }, { "word": "æ»š", "pinyin": "gÇ”n" },
                    { "word": "é¡¿", "pinyin": "dÃ¹n" }, { "word": "é€", "pinyin": "zhÃº" }, { "word": "æ¸", "pinyin": "jiÃ n" },
                    { "word": "å µ", "pinyin": "dÇ”" }, { "word": "çŠ¹", "pinyin": "yÃ³u" }, { "word": "è´¯", "pinyin": "guÃ n" },
                    { "word": "æµ©", "pinyin": "hÃ o" }, { "word": "å´©", "pinyin": "bÄ“ng" }, { "word": "éœ‡", "pinyin": "zhÃ¨n" },
                    { "word": "éœ", "pinyin": "shÃ " }, { "word": "ä½™", "pinyin": "yÃº" }, { "word": "æ·˜", "pinyin": "tÃ¡o" },
                    { "word": "ç‰µ", "pinyin": "qiÄn" }, { "word": "é¹…", "pinyin": "Ã©" }, { "word": "åµ", "pinyin": "luÇn" },
                    { "word": "å‘", "pinyin": "kÄ“ng" }, { "word": "æ´¼", "pinyin": "wÄ" }, { "word": "å¡«", "pinyin": "tiÃ¡n" },
                    { "word": "åº„", "pinyin": "zhuÄng" }, { "word": "ç¨¼", "pinyin": "jiÃ " }, { "word": "ä¿—", "pinyin": "sÃº" },
                    { "word": "è·ƒ", "pinyin": "yuÃ¨" }, { "word": "è‘¡", "pinyin": "pÃº" }, { "word": "è„", "pinyin": "tÃ¡o" },
                    { "word": "ç¨»", "pinyin": "dÃ o" }, { "word": "ç†Ÿ", "pinyin": "shÃº" }, { "word": "ç©—", "pinyin": "suÃ¬" },
                    { "word": "é•€", "pinyin": "dÃ¹" }, { "word": "åŸ‚", "pinyin": "gÄ›ng" }, { "word": "çƒ", "pinyin": "shuÃ²" },
                    { "word": "å·¢", "pinyin": "chÃ¡o" }, { "word": "è‹‡", "pinyin": "wÄ›i" }, { "word": "ç½—", "pinyin": "luÃ³" },
                    { "word": "çœ ", "pinyin": "miÃ¡n" }, { "word": "éœ¸", "pinyin": "bÃ " }, { "word": "å ", "pinyin": "zhÃ n" },
                    { "word": "æ˜§", "pinyin": "mÃ¨i" }, { "word": "å ", "pinyin": "zhuÃ¬" }, { "word": "æ€€", "pinyin": "huÃ¡i" }
                ]
            }
        };
        // ========== é…ç½®å—ç»“æŸ ==========

        ; (function () {
            "use strict";
            const CFG = window.WRM_CONFIG;
            if (window.OFFLINE_CONFIG) {
                console.log('ğŸš€ å¼ºåˆ¶å¯åŠ¨ç¦»çº¿é…ç½®æ¨¡å¼ (OFFLINE_CONFIG)');
            }
            const W = 450, H = 800;
            const canvas = document.getElementById('gc');
            const ctx = canvas.getContext('2d');
            canvas.width = W; canvas.height = H;

            // ===== è‡ªé€‚åº”ç¼©æ”¾ =====
            function resize() {
                const ww = window.innerWidth, wh = window.innerHeight;
                const scale = Math.min(ww / W, wh / H);
                const cw = W * scale, ch = H * scale;
                canvas.style.width = cw + 'px';
                canvas.style.height = ch + 'px';
                const hud = document.getElementById('hud');
                hud.style.width = cw + 'px';
                hud.style.height = ch + 'px';
                // å±…ä¸­ HUD åœ¨ canvas ä¸Šæ–¹
                hud.style.left = ((ww - cw) / 2) + 'px';
                hud.style.top = ((wh - ch) / 2) + 'px';
            }
            window.addEventListener('resize', resize); resize();

            // ===== éŸ³é¢‘å¼•æ“ =====
            let audioCtx = null;
            function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); }
            function synth(freq, type, decay, vol) {
                ensureAudio();
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
                o.frequency.exponentialRampToValueAtTime(Math.max(freq * 0.01, 1), audioCtx.currentTime + decay);
                g.gain.setValueAtTime(vol, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + decay);
                o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + decay);
            }
            function speakWord(text) {
                if (!('speechSynthesis' in window)) return;
                const u = new SpeechSynthesisUtterance(text); u.lang = 'zh-CN'; u.rate = 0.85;
                window.speechSynthesis.speak(u);
            }
            let bgmNodes = [];
            function startBGM() {
                ensureAudio();
                const master = audioCtx.createGain(); master.gain.value = 0.03; master.connect(audioCtx.destination);
                [110, 165, 220, 330].forEach((f, i) => {
                    const o = audioCtx.createOscillator(); o.type = 'sine'; o.frequency.value = f; o.detune.value = i * 3;
                    o.connect(master); o.start(); bgmNodes.push(o);
                });
            }
            function stopBGM() { bgmNodes.forEach(o => { try { o.stop(); } catch (e) { } }); bgmNodes = []; }
            const SFX = {
                correct(data) {
                    synth(880, 'sine', 0.15, 0.25); synth(1100, 'sine', 0.2, 0.15);
                    // v2.8: æ’å‡»æ­£ç¡®é¡¹æ—¶åªæ’­æ”¾æ±‰å­—è¯»éŸ³
                    if (data.word) setTimeout(() => speakWord(data.word), 150);
                },
                wrong() { synth(150, 'sawtooth', 0.3, 0.2); synth(120, 'square', 0.2, 0.15); },
                hit() { synth(80, 'square', 0.15, 0.3); },
                jump() { synth(400, 'sine', 0.1, 0.1); synth(600, 'sine', 0.08, 0.08); },
                levelUp() { synth(523, 'sine', 0.2, 0.2); setTimeout(() => synth(659, 'sine', 0.2, 0.2), 150); setTimeout(() => synth(784, 'sine', 0.3, 0.2), 300); },
                gameOver() { synth(300, 'sawtooth', 0.5, 0.2); synth(200, 'sawtooth', 0.6, 0.15); }
            };

            // ===== æ¸¸æˆçŠ¶æ€ =====
            const ST = {
                running: false, paused: false, gameOver: false,
                lives: CFG.rules.initLives, score: 0, combo: 0, maxCombo: 0,
                levelIndex: 0, levelTime: 0, levelTimer: 0,
                correctTotal: 0, correctStreak: 0, wrongStreak: 0,
                currentPinyin: '', currentWord: '', currentCorrectWord: '', // v2.8: æœ¬å…³å”¯ä¸€æ­£ç¡®æ±‰å­—
                trackIndex: 1, playerJump: 0, vy: 0, isGrounded: true, playerAnim: 0,
                landingScale: 1.0, // è½åœ°æŒ¤å‹ç¼©æ”¾
                isRunning: false, runSpeedMultiplier: 1.0, // v2.8: è·‘åŠ¨çŠ¶æ€å’Œé€Ÿåº¦å€ç‡
                runAnimPhase: 0, // v2.8.3: è·‘åŠ¨åŠ¨ç”»é˜¶æ®µ
                objects: [], particles: [], roadLines: [],
                streakLevels: 0, totalLevelsCleared: 0,
                completedWordCount: 0, // v2.8: å·²å®Œæˆçš„å­—æ•°ï¼ˆç”¨äºæ˜¾ç¤ºæ€»è¿›åº¦ï¼‰
                failedLevelIndex: -1, // v2.8: å¤±è´¥æ—¶çš„å…³å¡ç´¢å¼•
                ringCompleteAnim: 0, // v2.8: å¤–ç¯å®ŒæˆåŠ¨ç”»è¿›åº¦
                appearedCorrectWords: new Set(), // v2.5: è·Ÿè¸ªå·²å‡ºç°çš„åŒéŸ³å­—
                gamePhase: 'soundToWord', // v4.1: æ¸¸æˆé˜¶æ®µ soundToWord | wordToSound
                currentTaskDisplay: '', // v4.1: ä»»åŠ¡åŒºæ˜¾ç¤ºå†…å®¹
                dt: 0, lastTime: 0, frameCount: 0
            };

            // ===== å…³å¡æ•°æ® =====
            // v4.0: ç”¨å‡½æ•°å–ä»£constï¼Œç¡®ä¿loadConfigåå§‹ç»ˆè¯»å–æœ€æ–°æ•°æ®
            function getAllData() { return CFG.dataSource.offlineData; }
            let pinyinList = getAllData().map(d => d.pinyin);
            let wordList = getAllData().map(d => d.word); // v4.1: å­—æ‰¾éŸ³ç”¨

            // ===== æ•°ç»„æ´—ç‰Œ =====
            function shuffleArray(arr) {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            // ===== ç­‰çº§è®¡ç®— =====
            function getLevel(score) {
                // ä¼˜å…ˆä½¿ç”¨é…ç½®ä¸­çš„ç­‰çº§è§„åˆ™
                const grades = (CFG.character && CFG.character.grades) || [
                    { name: "è¯†å­—æ–°å…µ", score: 0 },
                    { name: "å¤§å¸ˆ", score: 10000 }
                ];
                let lv = grades[0];
                for (const l of grades) {
                    if (score >= l.score) lv = l;
                }
                return { rank: lv.name || lv.rank };
            }

            // ===== éš¾åº¦æ›²çº¿ =====
            function getDifficulty() {
                const t = Math.min(ST.levelTime / CFG.rules.levelTime, 1);
                const d = CFG.difficulty;
                const lerp = (a, b) => a + (b - a) * t;
                return {
                    speed: lerp(d.speedStart, d.speedEnd),
                    interval: lerp(d.intervalStart, d.intervalEnd),
                    pObstacle: lerp(d.obstacleStart, d.obstacleEnd),
                    pWrong: lerp(d.wrongStart, d.wrongEnd),
                    pCorrect: lerp(d.correctStart, d.correctEnd)
                };
            }

            // ===== localStorage é…ç½®ç®¡ç† =====
            function loadConfig() {
                try {
                    // ä¼˜å…ˆè¯»å–å†…åµŒé…ç½®ï¼ˆç‹¬ç«‹å¯¼å‡ºåŒ…ä¸“ç”¨ï¼Œè§£å†³ File åè®®é™åˆ¶ï¼‰
                    let config = null;
                    if (window.OFFLINE_CONFIG) {
                        config = window.OFFLINE_CONFIG;
                        console.log('ğŸ“¦ ä½¿ç”¨å†…åµŒé…ç½® (OFFLINE_CONFIG) å¯åŠ¨');
                    } else if (window.FORCE_OFFLINE_CONFIG) {
                        config = window.FORCE_OFFLINE_CONFIG;
                        console.log('ğŸ“¦ ä½¿ç”¨å†…åµŒé…ç½® (FORCE_OFFLINE_CONFIG) å¯åŠ¨');
                    } else if (window.EMBEDDED_CONFIG) {
                        config = window.EMBEDDED_CONFIG;
                        console.log('ğŸ“¦ ä½¿ç”¨å†…åµŒé…ç½® (EMBEDDED_CONFIG) å¯åŠ¨');
                    } else {
                        const saved = localStorage.getItem('WRM_UserConfig');
                        if (!saved) return;
                        config = JSON.parse(saved);
                    }

                    // â”€â”€ å…¼å®¹æ—§æ ¼å¼ï¼ˆç›´æ¥æœ‰ rules/physics/difficulty/ui å­—æ®µï¼‰â”€â”€
                    if (config.rules) Object.assign(CFG.rules, config.rules);
                    if (config.physics) Object.assign(CFG.physics, config.physics);
                    if (config.difficulty) Object.assign(CFG.difficulty, config.difficulty);
                    if (config.ui) Object.assign(CFG.ui, config.ui);

                    // â”€â”€ é…ç½®ä¸­å¿ƒ v2.0 æ–°æ ¼å¼æ˜ å°„ â”€â”€
                    // ç‰©ç†å¼•æ“
                    const pe = config.physical_engine;
                    if (pe) {
                        if (pe.obstacleScale) {
                            if (pe.obstacleScale.near !== undefined) CFG.physics.objScaleEnd = pe.obstacleScale.near;
                            if (pe.obstacleScale.far !== undefined) CFG.physics.objScaleStart = pe.obstacleScale.far;
                        }
                        if (pe.itemScale) {
                            // itemScale ä¸ objScale å…±äº«ï¼ˆæ¸¸æˆä¸­ç»Ÿä¸€å¤„ç†ï¼‰
                            if (pe.itemScale.far !== undefined) CFG.physics.objScaleStart = pe.itemScale.far;
                            if (pe.itemScale.near !== undefined) CFG.physics.objScaleEnd = pe.itemScale.near;
                        }
                        if (pe.physics) {
                            if (pe.physics.jumpForce !== undefined) CFG.physics.jumpForce = pe.physics.jumpForce;
                            if (pe.physics.gravity !== undefined) CFG.physics.gravity = pe.physics.gravity;
                        }
                    }

                    // å°å…³é€šå…³è®¾ç½®
                    const ls = config.level_settings;
                    if (ls) {
                        if (ls.goals) {
                            if (ls.goals.timeLimit !== undefined) CFG.rules.levelTime = ls.goals.timeLimit;
                            if (ls.goals.targetCount !== undefined) CFG.rules.winCorrectTotal = ls.goals.targetCount;
                            if (ls.goals.comboTarget !== undefined) CFG.rules.winCorrectStreak = ls.goals.comboTarget;
                        }
                        if (ls.fail) {
                            if (ls.fail.comboWrong !== undefined) CFG.rules.failWrongStreak = ls.fail.comboWrong;
                            // totalWrong æš‚ç”±ç”Ÿå‘½å€¼ç³»ç»Ÿå…œåº•
                        }
                    }

                    // éš¾åº¦è®¾ç½®
                    const diff = config.difficulty_and_level || config.difficulty;
                    if (config.difficulty && config.difficulty.spawn) {
                        const sp = config.difficulty.spawn;
                        if (sp.targetDensity !== undefined) CFG.difficulty.correctStart = sp.targetDensity;
                        if (sp.distractorDensity !== undefined) CFG.difficulty.wrongStart = sp.distractorDensity;
                        if (sp.obstacleDensity !== undefined) CFG.difficulty.obstacleStart = sp.obstacleDensity;
                    }

                    // è®¡åˆ†ç³»ç»Ÿ
                    const sc = config.scoring;
                    if (sc) {
                        if (sc.base) {
                            if (sc.base.hitTarget !== undefined) CFG.scoring.correctBase = sc.base.hitTarget;
                            if (sc.base.hitDistractor !== undefined) CFG.scoring.hitDistractor = sc.base.hitDistractor;
                            if (sc.base.hitObstacle !== undefined) CFG.scoring.hitObstacle = sc.base.hitObstacle;
                        }
                        if (sc.combo) {
                            // è¿å‡»æœ€å¤§å€¼å–æœ€é«˜å®šä¹‰çš„è¿å‡»æ•°
                            CFG.scoring.comboMax = 5;
                            // å­˜å‚¨è¿å‡»å¥–åŠ±è¡¨ä¾›æ¸¸æˆä½¿ç”¨
                            CFG.scoring.comboRewards = {};
                            if (sc.combo.combo2 !== undefined) CFG.scoring.comboRewards[2] = sc.combo.combo2;
                            if (sc.combo.combo3 !== undefined) CFG.scoring.comboRewards[3] = sc.combo.combo3;
                            if (sc.combo.combo4 !== undefined) CFG.scoring.comboRewards[4] = sc.combo.combo4;
                            if (sc.combo.combo5 !== undefined) CFG.scoring.comboRewards[5] = sc.combo.combo5;
                        }
                        if (sc.lives) {
                            if (sc.lives.initLives !== undefined) CFG.rules.initLives = sc.lives.initLives;
                            if (sc.lives.distractorDamage !== undefined) CFG.rules.wrongDamage = sc.lives.distractorDamage;
                            if (sc.lives.obstacleDamage !== undefined) CFG.rules.obstacleDamage = sc.lives.obstacleDamage;
                        }
                    }

                    // è§’è‰²è®¾ç½®
                    const ch = config.character;
                    if (ch) {
                        if (ch.nickname) CFG.metadata.playerName = ch.nickname;
                        if (Array.isArray(ch.grades) && ch.grades.length > 0) {
                            CFG.levels = ch.grades.map(g => ({
                                rank: g.name,
                                threshold: g.score
                            }));
                        }
                    }

                    // å•å…ƒå…³å¡è®¾ç½®ï¼ˆæ¨¡å¼/CSVæ•°æ®ï¼‰
                    const us = config.unit_settings;
                    if (us) {
                        if (us.unitName) CFG.metadata.unitTitle = us.unitName;
                        if (us.mode === 'soundToWord') {
                            CFG.levelDesign = CFG.levelDesign || {};
                            CFG.levelDesign.levelName = 'éŸ³æ‰¾å­—';
                            CFG.levelDesign.taskSource = 'pinyin';
                            CFG.levelDesign.correctSource = 'word';
                            CFG.levelDesign.wrongSource = 'word_exclude_homophone';
                        } else if (us.mode === 'wordToSound') {
                            CFG.levelDesign = CFG.levelDesign || {};
                            CFG.levelDesign.levelName = 'å­—æ‰¾éŸ³';
                            CFG.levelDesign.taskSource = 'word';
                            CFG.levelDesign.correctSource = 'pinyin';
                            CFG.levelDesign.wrongSource = 'pinyin';
                        }
                        // CSV æ•°æ®æ³¨å…¥
                        if (Array.isArray(us.csvData) && us.csvData.length > 0) {
                            CFG.dataSource.offlineData = us.csvData.map(row => ({
                                word: row.word || '',
                                pinyin: row.pinyin || ''
                            }));
                        }
                    }

                } catch (e) {
                    console.warn('Failed to load config:', e);
                }
                syncUIText();
            }

            // v4.3: åŒæ­¥ UI æ–‡å­— (æ ‡é¢˜/é¦–å±)
            function syncUIText() {
                if (CFG.metadata && CFG.metadata.unitTitle) {
                    // å¼ºåˆ¶é”å®šæµè§ˆå™¨æ ‡ç­¾é¡µæ ‡é¢˜å’Œæ¸¸æˆæ ‡é¢˜ä¸ºâ€œå­—è·‘å¤§å¸ˆâ€
                    document.title = 'å­—è·‘å¤§å¸ˆ';
                    // ä¿æŒå¯åŠ¨ç•Œé¢æ ‡é¢˜å†…å®¹å›ºå®šï¼Œä¸ä» unitTitle åŒæ­¥
                    console.log('ğŸ“ æ ‡é¢˜å·²é”å®šä¸ºï¼šå­—è·‘å¤§å¸ˆ');
                }
            }
            function saveConfig() {
                try {
                    const config = {
                        ui: { isInvincible: CFG.ui.isInvincible },
                        difficulty: { ...CFG.difficulty },
                        rules: { ...CFG.rules },
                        physics: { ...CFG.physics }
                    };
                    localStorage.setItem('WRM_UserConfig', JSON.stringify(config));
                } catch (e) {
                    console.warn('Failed to save config:', e);
                }
            }

            // ===== é€è§†è®¡ç®— =====
            const VP = { x: W / 2, y: 0 }; // y å°†åœ¨ drawTrack ä¸­åŠ¨æ€è®¡ç®—
            function perspScale(y) {
                const t = (y - VP.y) / (H - VP.y);
                const sStart = CFG.physics.objScaleStart;
                const sEnd = CFG.physics.objScaleEnd;
                return sStart + (sEnd - sStart) * t;
            }
            // v2.9.3: è·‘é“é€è§†ç¼©æ”¾ä¸ç‰©ä½“ç¼©æ”¾åˆ†ç¦»
            function trackScale(y) {
                const t = (y - VP.y) / (H - VP.y);
                const sStart = 0.08; // è·‘é“è¿œç«¯å›ºå®šç¼©æ”¾
                const sEnd = 1.0;    // è·‘é“è¿‘ç«¯å›ºå®šç¼©æ”¾
                return sStart + (sEnd - sStart) * t;
            }
            function trackX(trackIdx, y) {
                const s = trackScale(y); // ä½¿ç”¨ç‹¬ç«‹çš„è·‘é“ç¼©æ”¾
                const baseX = CFG.physics.tracksX[trackIdx] * W;

                const t = (y - VP.y) / (H - VP.y);
                // å°† 0.25 æ”¹å°ï¼ˆä¾‹å¦‚ 0.1ï¼‰ï¼Œè·‘é“åº•éƒ¨ä¼šæ‰©å¼ å¾—æ›´å¼€ï¼Œç¬¦åˆå›¾ç‰‡æ¯”ä¾‹
                const shrinkFactor = 1.0 - t * 0.1;
                return VP.x + (baseX - VP.x) * s * shrinkFactor;
            }

            // ===== ç²’å­ç³»ç»Ÿ =====
            function spawnParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    ST.particles.push({
                        x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8 - 3,
                        life: 1, decay: 0.01 + Math.random() * 0.02,
                        size: 2 + Math.random() * 4, color,
                        type: Math.random() > 0.5 ? 'circle' : 'star'
                    });
                }
            }
            function updateParticles() {
                for (let i = ST.particles.length - 1; i >= 0; i--) {
                    const p = ST.particles[i];
                    p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life -= p.decay;
                    if (p.life <= 0) ST.particles.splice(i, 1);
                }
            }
            function drawParticles() {
                ST.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    // v3.0: çº¸å±‘é£æ ¼ç²’å­ï¼Œæ— å‘å…‰ï¼Œæ—‹è½¬æ­£æ–¹å½¢æˆ–åœ†å½¢
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.life * 5); // æ—‹è½¬æ•ˆæœ
                    if (p.type === 'circle') {
                        ctx.beginPath(); ctx.arc(0, 0, p.size * p.life, 0, Math.PI * 2); ctx.fill();
                    } else {
                        // ç¢çº¸ç‰‡ (æ–¹å½¢)
                        ctx.fillRect(-p.size * p.life, -p.size * p.life, p.size * p.life * 2, p.size * p.life * 2);
                    }
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
            }
            function drawStar(cx, cy, r) {
                // ä¿ç•™äº”è§’æ˜Ÿé€»è¾‘ï¼Œç”¨äºç‰¹æ•ˆï¼Œä½†ä¹Ÿå¯ä»¥ç®€åŒ–
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const a = Math.PI * 2 * i / 5 - Math.PI / 2;
                    const x = cx + Math.cos(a) * r, y = cy + Math.sin(a) * r;
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                    const a2 = a + Math.PI / 5;
                    ctx.lineTo(cx + Math.cos(a2) * r * 0.4, cy + Math.sin(a2) * r * 0.4);
                }
                ctx.closePath(); ctx.fill();
            }

            // ===== v3.0: çº¸è´¨é£æ ¼æ¸²æŸ“è¾…åŠ©å‡½æ•° (New Helper Functions) =====
            let paperPattern = null;
            function createPaperPattern() {
                if (paperPattern) return paperPattern;
                const pCanvas = document.createElement('canvas');
                pCanvas.width = 256; pCanvas.height = 256;
                const pCtx = pCanvas.getContext('2d');
                // åŸºç¡€æ·±ç°è‰²èƒŒæ™¯
                pCtx.fillStyle = '#2D3436';
                pCtx.fillRect(0, 0, 256, 256);
                // æ·»åŠ å™ªç‚¹çº¹ç†
                for (let i = 0; i < 6000; i++) {
                    pCtx.fillStyle = 'rgba(255,255,255,0.03)';
                    pCtx.fillRect(Math.random() * 256, Math.random() * 256, 2, 2);
                }
                paperPattern = ctx.createPattern(pCanvas, 'repeat');
                return paperPattern;
            }

            // ç»˜åˆ¶ç²—ç³™è¾¹ç¼˜è·¯å¾„ (Wobble Effect)
            function drawRoughPath(ctx, points, closePath = false) {
                if (points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                    const steps = Math.max(1, Math.floor(dist / 20)); // æ¯20pxä¸€ä¸ªæ‰°åŠ¨ç‚¹

                    for (let j = 1; j <= steps; j++) {
                        const t = j / steps;
                        const bx = p1.x + (p2.x - p1.x) * t;
                        const by = p1.y + (p2.y - p1.y) * t;
                        // éšæœºæ‰°åŠ¨ (-1.5 åˆ° 1.5)
                        const jitX = (Math.random() - 0.5) * 3;
                        const jitY = (Math.random() - 0.5) * 3;
                        ctx.lineTo(bx + jitX, by + jitY);
                    }
                }
                if (closePath) {
                    ctx.closePath();
                }
                // ä¸åœ¨è¿™é‡Œ stroke/fillï¼Œç•™ç»™è°ƒç”¨è€…
            }

            // ===== è·‘é“ç»˜åˆ¶ (Paper Cutout Style) =====
            function drawTrack() {
                const titleBottom = 20 + 36 + 10;
                const taskUIY = titleBottom + 80;
                VP.y = taskUIY;

                // 1. å…¨å±èƒŒæ™¯ (çº¸å¼ çº¹ç†)
                ctx.fillStyle = createPaperPattern();
                ctx.fillRect(0, 0, W, H);

                // 2. ç»˜åˆ¶è·‘é“ä¸»ä½“ (å¤§å‰ªçº¸å¸¦)
                // è®¡ç®—å·¦å³è¾¹ç¼˜çš„å…³é”®ç‚¹
                const trackCheckPointsY = [VP.y, VP.y + (H - VP.y) * 0.25, VP.y + (H - VP.y) * 0.5, VP.y + (H - VP.y) * 0.75, H];
                const leftPoints = [];
                const rightPoints = [];

                trackCheckPointsY.forEach(y => {
                    const lBase = trackX(0, y);
                    const rBase = trackX(2, y);
                    const lw = rBase - lBase; // ä¸¤ä¸ªè½¦é“å®½ (å› ä¸º trackXæ˜¯ä¸­å¿ƒç‚¹)
                    // trackX(0)æ˜¯å·¦è½¦é“ä¸­å¿ƒï¼ŒtrackX(2)æ˜¯å³è½¦é“ä¸­å¿ƒã€‚
                    // è·‘é“æ€»å·¦è¾¹ç¼˜ = trackX(0) - 0.5 * å•è½¦é“å®½
                    // è·‘é“æ€»å³è¾¹ç¼˜ = trackX(2) + 0.5 * å•è½¦é“å®½
                    // ä½†æ˜¯ trackX æ˜¯åŸºäº tracksX é…ç½® [1/6, 1/2, 5/6]
                    // æ‰€ä»¥ trackX(1) - trackX(0) = 1/3 W * s
                    // å•è½¦é“å®½ = trackX(1) - trackX(0)
                    const laneW = trackX(1, y) - trackX(0, y);

                    // ç¨å¾®åŠ å®½ä¸€ç‚¹è¾¹ç¼˜ä½œä¸ºè·‘é“çº¸å¸¦è¾¹ç•Œ
                    leftPoints.push({ x: trackX(0, y) - laneW * 0.6, y: y });
                    rightPoints.push({ x: trackX(2, y) + laneW * 0.6, y: y });
                });

                // æ„å»ºå®Œæ•´çš„å¤šè¾¹å½¢è·¯å¾„
                const polyPoints = [...leftPoints, ...rightPoints.reverse()];

                ctx.save();
                // ç™½è‰²æ¯›è¾¹é˜´å½± (Hard Shadow)
                ctx.translate(2, 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                drawRoughPath(ctx, polyPoints, true);
                ctx.fill();
                ctx.translate(-2, -2);

                // è·‘é“æœ¬ä½“ (æ·±ä¸€ç‚¹çš„ç±³è‰²æˆ–æµ…ç°ï¼Œæ¨¡æ‹Ÿé‡å çº¸å¼ )
                ctx.fillStyle = '#EBE7DD'; // ç•¥æ·±äºèƒŒæ™¯
                drawRoughPath(ctx, polyPoints, true);
                ctx.fill();

                // è¾¹ç¼˜æè¾¹ (é“…ç¬”ç—•è¿¹)
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();

                // 3. ç»˜åˆ¶è½¦é“åˆ†éš”çº¿ (è™šçº¿å‰ªè£æ•ˆæœ)
                ctx.save();
                ctx.strokeStyle = 'rgba(0,0,0,0.15)'; // æ·¡æ·¡çš„å‹ç—•è‰²
                ctx.lineWidth = 2;
                ctx.setLineDash([15, 15]); // å®½è™šçº¿

                // çº¿1 (è·‘é“ 0|1 ä¹‹é—´)
                // çº¿2 (è·‘é“ 1|2 ä¹‹é—´)
                // trackX(0) æ˜¯ç¬¬ä¸€è½¦é“ä¸­å¿ƒã€‚åˆ†éš”çº¿åº”åœ¨ trackX(0) + laneW/2
                // å…¶å® trackX(0)å’ŒtrackX(1)çš„ä¸­ç‚¹å°±æ˜¯åˆ†éš”çº¿
                const divLines = [0, 1];
                divLines.forEach(idx => {
                    const points = [];
                    trackCheckPointsY.forEach(y => {
                        const x = (trackX(idx, y) + trackX(idx + 1, y)) / 2;
                        points.push({ x, y });
                    });

                    // ç”¨ rough path ç»˜åˆ¶è™šçº¿æœ‰ç‚¹å¥‡æ€ªï¼Œç›´æ¥ç”»å¸¦æŠ–åŠ¨çš„è™šçº¿
                    // è¿™é‡Œç®€åŒ–ï¼Œç›´æ¥ç”»ç›´è™šçº¿ï¼Œé…åˆæ‰‹ç»˜é£èƒŒæ™¯å³å¯
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    points.forEach((p, i) => { if (i > 0) ctx.lineTo(p.x, p.y); });
                    ctx.stroke();
                });
                ctx.restore();

                // 4. èµ·è·‘çº¿/è£…é¥°æ¨ªçº¿ (è´´çº¸æ¡)
                // ç§»åŠ¨çš„è·‘é“è£…é¥°çº¿
                ST.roadLines.forEach(rl => {
                    const s = trackScale(rl.y);
                    const h = s * 20;

                    // ç»˜åˆ¶åœ¨ä¸¤ä¸ªåˆ†éš”çº¿ä½ç½®çš„å°æ¨ªè´´çº¸
                    for (let i = 0; i < 2; i++) {
                        const xLeft = trackX(i, rl.y);
                        const xRight = trackX(i + 1, rl.y);
                        const cx = (xLeft + xRight) / 2;
                        const w = 30 * s;

                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(cx - w / 2, rl.y, w, h);
                    }
                });

                // 5. å•å…ƒä¿¡æ¯æ˜¾ç¤ºï¼ˆè·‘é“æœ€ä¸‹æ–¹ï¼‰
                ctx.save();
                ctx.font = '12px "Microsoft YaHei"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillStyle = 'rgba(180, 170, 155, 0.7)';
                ctx.fillText(CFG.metadata.unitTitle || '', W / 2, H - 8);
                ctx.restore();
            }
            function updateRoadLines() {
                const diff = getDifficulty();
                // æ·»åŠ æ–°çº¿
                if (ST.frameCount % 15 === 0) {
                    ST.roadLines.push({ y: VP.y });
                }
                // v2.8: ç§»åŠ¨ï¼ˆå—è·‘åŠ¨é€Ÿåº¦å½±å“ï¼‰
                for (let i = ST.roadLines.length - 1; i >= 0; i--) {
                    ST.roadLines[i].y += diff.speed * 1.5 * ST.runSpeedMultiplier;
                    if (ST.roadLines[i].y > H) ST.roadLines.splice(i, 1);
                }
            }

            // ===== è·³è·ƒè½¨è¿¹ç»˜åˆ¶ =====
            // ===== è·³è·ƒè½¨è¿¹ç»˜åˆ¶ (ç¼çº«çº¿é£æ ¼) =====
            function drawJumpTrajectory() {
                if (ST.isGrounded) return;

                ctx.save();
                ctx.strokeStyle = '#555'; // æ·±è‰²ç¼è¡£çº¿
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // æ˜æ˜¾çš„è™šçº¿

                ctx.beginPath();
                const px = trackX(ST.trackIndex, H * CFG.physics.playerY);
                const py = H * CFG.physics.playerY - ST.playerJump;

                // æ¨¡æ‹ŸæŠ›ç‰©çº¿è½¨è¿¹
                let simY = ST.playerJump;
                let simVy = ST.jumpVy;
                const dt = 1 / 60;

                ctx.moveTo(px, py);
                let landingY = py;
                for (let i = 0; i < 60 && simY >= 0; i++) {
                    simY += simVy * dt;
                    simVy -= CFG.physics.gravity * dt;
                    const nextY = H * CFG.physics.playerY - simY;
                    ctx.lineTo(px, nextY);
                    landingY = nextY;
                }

                ctx.stroke();
                ctx.setLineDash([]);

                // è½ç‚¹æ ‡è®° (å·²ç§»é™¤)

                ctx.restore();
            }

            // ===== v3.0: çº¸å¶è§’è‰²ç»˜åˆ¶ (Paper Puppet - Back View & Scaled) =====
            function drawPlayer() {
                const ti = ST.trackIndex;
                const py = H * CFG.physics.playerY;
                const px = trackX(ti, py);
                const baseScale = CFG.physics.playerScale * 1.5; // v3.2: æ”¾å¤§ 50%
                const sX = baseScale * (2 - ST.landingScale);
                const sY = baseScale * ST.landingScale;

                const jy = ST.playerJump;
                const t = ST.playerAnim;
                const tc = '#F7B731'; // èº«ä½“ä¸»è‰² (æš–é»„)
                const pantsColor = '#2D3436'; // è£¤å­æ·±ç°
                const skinColor = '#FFDAB9'; // çš®è‚¤ç²‰è‰²

                const animPhase = ST.isRunning ? ST.runAnimPhase : t;
                const runCycle = Math.sin(animPhase);
                const runCycle2 = Math.cos(animPhase);

                // èº«ä½“é¢ ç°¸
                let bobbing = 0;
                if (ST.isRunning && ST.isGrounded) {
                    bobbing = Math.abs(Math.sin(animPhase * 2)) * 6 * sY;
                }
                const by = py - jy - bobbing;

                // å½±å­ (ç¡¬è¾¹æ·±è‰²æ¤­åœ†)
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; // æ·±è‰²ç¡¬æŠ•å½±
                const shadowScale = Math.max(0.2, 1 - jy / 200);

                ctx.beginPath();
                ctx.ellipse(px + 4, py + 8 * sY + 2, 18 * sX * shadowScale, 5 * sY * shadowScale, 0, 0, Math.PI * 2);
                ctx.fill();

                // æ¢å¤è½åœ°å½¢å˜
                if (ST.landingScale < 1.0) {
                    ST.landingScale += 0.05;
                    if (ST.landingScale > 1.0) ST.landingScale = 1.0;
                }

                const headR = 10 * sY;
                const bodyW = 16 * sX, bodyH = 22 * sY;
                const limbW = 5 * sX;

                // ç»˜åˆ¶çº¸å¶éƒ¨ä»¶å‡½æ•°
                function drawLimb(x1, y1, x2, y2, color, w) {
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    // æ¨¡æ‹Ÿå‰ªçº¸è¾¹ç¼˜
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    // é“†é’‰
                    ctx.fillStyle = '#b2bec3';
                    ctx.beginPath(); ctx.arc(x1, y1, w * 0.3, 0, Math.PI * 2); ctx.fill();
                }

                // å¢å¼ºè·‘åŠ¨å¹…åº¦
                const swingMultiplier = ST.isRunning ? 2.5 : 1.0;
                let legSwingY = runCycle * 12 * sY * swingMultiplier;
                let legSwingX = Math.abs(runCycle) * 3 * sX;

                if (!ST.isGrounded) {
                    legSwingY = 8 * sY;
                    legSwingX = 2 * sX;
                }

                // ä¸‹åŠèº« (è…¿) - Leg drawing logic
                // å·¦è…¿
                drawLimb(px - 4 * sX, by - 4 * sY, px - 4 * sX - legSwingX * 0.3, by + 10 * sY - legSwingY, pantsColor, limbW); // å¤§è…¿
                drawLimb(px - 4 * sX - legSwingX * 0.3, by + 10 * sY - legSwingY, px - 4 * sX, by + 18 * sY - legSwingY * 0.5, pantsColor, limbW); // å°è…¿

                // å³è…¿
                drawLimb(px + 4 * sX, by - 4 * sY, px + 4 * sX + legSwingX * 0.3, by + 10 * sY + legSwingY, pantsColor, limbW);
                drawLimb(px + 4 * sX + legSwingX * 0.3, by + 10 * sY + legSwingY, px + 4 * sX, by + 18 * sY + legSwingY * 0.5, pantsColor, limbW);

                // èº«ä½“ (åœ†è§’çŸ©å½¢çº¸ç‰‡) - èƒŒé¢è§†è§’ï¼Œæ— éœ€é¢†å£è£…é¥°
                ctx.fillStyle = '#0984e3'; // è“è‰²è¡£æœ
                const bodyRot = runCycle * 0.1;
                ctx.save();
                ctx.translate(px, by - bodyH / 2);
                ctx.rotate(bodyRot);
                roundRect(-bodyW / 2, -bodyH / 2, bodyW, bodyH, 4 * sX);
                // èƒŒéƒ¨è£…é¥° (ç®€å•çš„çº¿æ¡æˆ– Logo) - å¯é€‰
                // ctx.fillStyle = 'rgba(255,255,255,0.3)';
                // ctx.fillRect(-bodyW*0.3, -bodyH*0.2, bodyW*0.6, 2*sY);
                ctx.restore();

                // å¤´éƒ¨ (èƒŒé¢ - ä¸»è¦æ˜¯å¤´å‘)
                const headY = by - bodyH - headR * 0.8;

                // 1. çš®è‚¤ (è„–å­/è€³æ ¹éƒ¨åˆ†)
                ctx.fillStyle = skinColor;
                ctx.beginPath(); ctx.arc(px, headY, headR, 0, Math.PI * 2); ctx.fill();

                // 2. å¤´å‘ (èƒŒé¢å®Œå…¨è¦†ç›–åè„‘å‹º)
                ctx.fillStyle = '#2d3436';
                ctx.beginPath();
                ctx.arc(px, headY, headR * 1.1, Math.PI, Math.PI * 2); // ä¸ŠåŠçƒ
                // ä¸‹éƒ¨è‡ªç„¶çš„çŸ­å‘å‘é™…çº¿
                ctx.lineTo(px + headR * 1.1, headY + headR * 0.5);
                ctx.quadraticCurveTo(px, headY + headR * 1.2, px - headR * 1.1, headY + headR * 0.5);
                ctx.fill();

                // æ‰‹è‡‚
                let armSwingY = -runCycle * 10 * sY * swingMultiplier;
                if (!ST.isGrounded) armSwingY = -12 * sY;

                // å·¦è‡‚ (Swing opposite to legs usually, but here runCycle is same? runCycle2 is cos.
                // Standard: Left Leg forward -> Right Arm forward.
                // legSwing is based on sin(t).
                // Let's use cos(t) for arms or inverted sin.
                const armCycle = -runCycle;

                // Arms attached at shoulders
                const shoulderY = by - bodyH + 2 * sY;
                const armW = limbW * 0.9;

                // å·¦è‡‚
                drawLimb(px - bodyW / 2, shoulderY, px - bodyW / 2 - 6 * sX, shoulderY + 8 * sY + armSwingY, skinColor, armW);
                drawLimb(px - bodyW / 2 - 6 * sX, shoulderY + 8 * sY + armSwingY, px - bodyW / 2 - 8 * sX, shoulderY + 16 * sY + armSwingY * 1.5, skinColor, armW);

                // å³è‡‚
                drawLimb(px + bodyW / 2, shoulderY, px + bodyW / 2 + 6 * sX, shoulderY + 8 * sY - armSwingY, skinColor, armW);
                drawLimb(px + bodyW / 2 + 6 * sX, shoulderY + 8 * sY - armSwingY, px + bodyW / 2 + 8 * sX, shoulderY + 16 * sY - armSwingY * 1.5, skinColor, armW);

                // æ˜µç§°æ ‡ç­¾ (çº¸æ¡é£æ ¼)
                const textW = ctx.measureText(CFG.metadata.playerName).width;
                const nameY = headY - headR - 10 * sY; // å¤´é¡¶ä¸Šæ–¹

                ctx.font = `bold ${14 * sY}px "Microsoft YaHei"`; ctx.textAlign = 'center';
                // ç™½è‰²åº•æ ‡ç­¾
                ctx.fillStyle = '#fff';
                ctx.fillRect(px - textW / 2 - 4, nameY - 14, textW + 8, 18);
                ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.strokeRect(px - textW / 2 - 4, nameY - 14, textW + 8, 18);

                ctx.fillStyle = '#333';
                ctx.fillText(CFG.metadata.playerName, px, nameY);

                ctx.restore();
            }

            // åœ†è§’çŸ©å½¢è¾…åŠ©
            function roundRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath(); ctx.fill();
            }

            // HEXè½¬RGB
            function hexToRGB(hex) {
                const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            }

            // ===== åœ†å½¢ä»»åŠ¡UI (ä¸­å¿ƒç‚¹ä¸æ¶ˆå¤±ç‚¹é‡åˆ) =====
            // ç»˜åˆ¶æ¸¸æˆæ ‡é¢˜
            // æ„å»ºæ¸¸æˆæ ‡é¢˜ (å¢¨æ°´é£æ ¼ -> è·‘é“è‰²)
            function drawGameTitle() {
                ctx.save();
                ctx.font = 'bold 36px "Microsoft YaHei"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                // é»‘è‰²æ°´å¢¨é˜´å½±
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillText('å­—è·‘å¤§å¸ˆ', W / 2, 22);
                // ä¸»è‰² (è·‘é“é¢œè‰²)
                ctx.fillStyle = '#EBE7DD';
                ctx.fillText('å­—è·‘å¤§å¸ˆ', W / 2, 20);

                ctx.restore();
            }

            function drawTaskRing() {
                // Position slightly lower to accommodate larger size
                const titleBottom = 20 + 36 + 10;
                const cx = W / 2;
                const ringR = W / 4.5;
                const cy = titleBottom + ringR + 20;

                ctx.save();
                ctx.translate(cx, cy);

                // 1. ç‰›çš®çº¸åŠç‰Œåº•åº§ (Kraft Paper Tag Base)
                // é˜´å½±
                ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 8; ctx.shadowOffsetY = 4;

                // å¤–åœˆ (æ·±æ£•è‰²/ç‰›çš®çº¸è‰²)
                ctx.fillStyle = '#8d6e63';
                ctx.beginPath(); ctx.arc(0, 0, ringR, 0, Math.PI * 2); ctx.fill();

                // çº¹ç† (ç®€å•å™ªç‚¹)
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for (let i = 0; i < 100; i++) {
                    const r = Math.random() * ringR;
                    const a = Math.random() * Math.PI * 2;
                    ctx.fillRect(Math.cos(a) * r, Math.sin(a) * r, 2, 2);
                }
                ctx.restore();

                // 2. å†…åœˆ (ç±³ç™½çº¸)
                const innerR = ringR * 0.82;
                ctx.fillStyle = '#faf3e0'; // Warmer
                ctx.beginPath(); ctx.arc(0, 0, innerR, 0, Math.PI * 2); ctx.fill();

                // å†…åœˆçº¹ç† (å¢å¼º)
                ctx.save();
                ctx.fillStyle = 'rgba(160, 140, 100, 0.08)'; // Brownish noise
                for (let i = 0; i < 300; i++) {
                    const r = Math.random() * innerR;
                    const a = Math.random() * Math.PI * 2;
                    const s = 1 + Math.random() * 2;
                    ctx.fillRect(Math.cos(a) * r, Math.sin(a) * r, s, s);
                }
                ctx.restore();

                // çº¸å¼ è¾¹ç¼˜å†…é˜´å½±æ•ˆæœ
                ctx.shadowColor = 'transparent';
                ctx.strokeStyle = '#d7ccc8';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, innerR, 0, Math.PI * 2); ctx.stroke();

                // 3. å¤–ç¯å‘¼å¸ç¯ï¼ˆå°å…³çŠ¶æ€ï¼‰â€” æ•°é‡ = ç´¯è®¡æ­£ç¡®æ•°
                ctx.shadowColor = 'transparent';
                const dotR = ringR * 0.96;
                const maxDots = CFG.rules.winCorrectTotal;
                const breathAlpha = 0.5 + 0.5 * Math.sin(ST.frameCount * 0.06); // å‘¼å¸èŠ‚å¥
                for (let i = 0; i < maxDots; i++) {
                    const a = (Math.PI * 2 * i) / maxDots;
                    const dx = Math.cos(a) * dotR;
                    const dy = Math.sin(a) * dotR;
                    ctx.beginPath();
                    ctx.arc(dx, dy, 4, 0, Math.PI * 2);
                    if (i < ST.correctTotal) {
                        // å·²ç‚¹äº®çš„å‘¼å¸ç¯ â€” é‡‘è‰²å…‰æ™•
                        ctx.fillStyle = `rgba(255, 200, 50, ${breathAlpha})`;
                        ctx.fill();
                        // å…‰æ™•
                        ctx.save();
                        ctx.shadowColor = 'rgba(255, 200, 50, 0.8)';
                        ctx.shadowBlur = 6 * breathAlpha;
                        ctx.beginPath();
                        ctx.arc(dx, dy, 4, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 215, 0, ${breathAlpha})`;
                        ctx.fill();
                        ctx.restore();
                    } else {
                        // æœªç‚¹äº®çš„æš—è‰²åœ†ç‚¹
                        ctx.fillStyle = '#d7ccc8';
                        ctx.fill();
                    }
                }

                // 4. (å·²ç§»é™¤é¡¶éƒ¨ç©¿å­”)

                // 5. å†…å®¹å±•ç¤º
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // å€’è®¡æ—¶ (ä¸Šæ–¹çº¢è‰²)
                const remaining = Math.max(0, Math.ceil(CFG.rules.levelTime - ST.levelTime));
                const timerFontSize = Math.floor(innerR * 0.35);
                ctx.fillStyle = remaining <= 10 ? '#ff3c3c' : '#d63031';
                ctx.font = `bold ${timerFontSize}px "Microsoft YaHei"`;
                ctx.fillText(remaining + 's', 0, -innerR * 0.45);

                // ä»»åŠ¡å†…å®¹ï¼ˆæ ¹æ®é˜¶æ®µåˆ‡æ¢ï¼‰
                if (ST.gamePhase === 'wordToSound') {
                    // å­—æ‰¾éŸ³ï¼šæ˜¾ç¤ºæ±‰å­—
                    ctx.fillStyle = '#2d3436';
                    const fontSize = Math.floor(innerR * 0.8);
                    ctx.font = `bold ${fontSize}px "Microsoft YaHei"`;
                    ctx.fillText(ST.currentTaskDisplay || '--', 0, innerR * 0.05);
                } else {
                    // éŸ³æ‰¾å­—ï¼šæ˜¾ç¤ºæ‹¼éŸ³
                    ctx.fillStyle = '#2980b9';
                    const fontSize = Math.floor(innerR * 0.7);
                    ctx.font = `bold ${fontSize}px "Microsoft YaHei"`;
                    ctx.fillText(ST.currentTaskDisplay || '--', 0, innerR * 0.05);
                }

                // è¿›åº¦ (ä¸‹æ–¹å°å­—)
                const currentList = ST.gamePhase === 'wordToSound' ? wordList : pinyinList;
                const progressText = `${ST.completedWordCount + 1}/${currentList.length}`;
                ctx.fillStyle = '#2d3436';
                ctx.font = `bold ${Math.floor(innerR * 0.25)}px "Microsoft YaHei"`;
                ctx.fillText(progressText, 0, innerR * 0.55);

                // é˜¶æ®µæ ‡ç­¾
                ctx.fillStyle = '#888';
                ctx.font = `${Math.floor(innerR * 0.18)}px "Microsoft YaHei"`;
                ctx.fillText(ST.gamePhase === 'wordToSound' ? 'å­—æ‰¾éŸ³' : 'éŸ³æ‰¾å­—', 0, -innerR * 0.72);

                ctx.restore();
            }

            // ===== ç‰©ä½“ç³»ç»Ÿ =====
            function spawnObject() {
                if (ST.paused || ST.gameOver || !ST.running) return;
                const diff = getDifficulty();
                let r = Math.random();
                let type, word = '', pinyin = '';

                // v2.6: æ­£ç¡®é¡¹ç”Ÿæˆä¿éšœ â€” ç¡®ä¿å…³å¡å†…èƒ½å‡ºç°è¶³å¤Ÿçš„æ­£ç¡®é¡¹
                const remaining = CFG.rules.levelTime - ST.levelTime;
                const needed = CFG.rules.winCorrectTotal - ST.correctTotal;
                if (needed > 0 && remaining > 0) {
                    const avgInterval = (CFG.difficulty.intervalStart + CFG.difficulty.intervalEnd) / 2;
                    const estimatedSpawns = remaining * 1000 / avgInterval;
                    const pCorrect = diff.pCorrect || (1 - diff.pObstacle - diff.pWrong);
                    if (estimatedSpawns * pCorrect < needed * 1.8) {
                        r = 1.0; // å¼ºåˆ¶è½å…¥ correct åŒºé—´
                    }
                }

                // ç¡®å®šç‰©ä½“ç±»å‹
                const pObs = diff.pObstacle;
                const pWrong = diff.pWrong;
                // pCorrect is the rest

                if (r < pObs) {
                    type = 'obstacle';
                } else if (r < pObs + pWrong) {
                    type = 'wrong';
                    if (ST.gamePhase === 'wordToSound') {
                        // å­—æ‰¾éŸ³ï¼šå¹²æ‰°é¡¹æ˜¯é”™è¯¯æ‹¼éŸ³
                        const correctPinyins = getAllData().filter(d => d.word === ST.currentCorrectWord).map(d => d.pinyin);
                        const pool = getAllData().filter(d => !correctPinyins.includes(d.pinyin));
                        if (pool.length > 0) { const item = pool[Math.floor(Math.random() * pool.length)]; word = item.pinyin; pinyin = item.pinyin; }
                        else { type = 'obstacle'; }
                    } else {
                        // éŸ³æ‰¾å­—ï¼šå¹²æ‰°é¡¹æ˜¯é”™è¯¯æ±‰å­—
                        const correctWords = getAllData().filter(d => d.pinyin === ST.currentPinyin).map(d => d.word);
                        const pool = getAllData().filter(d => d.pinyin !== ST.currentPinyin && !correctWords.includes(d.word));
                        if (pool.length > 0) { const item = pool[Math.floor(Math.random() * pool.length)]; word = item.word; pinyin = item.pinyin; }
                        else { type = 'obstacle'; }
                    }
                } else {
                    type = 'correct';
                    if (ST.gamePhase === 'wordToSound') {
                        // å­—æ‰¾éŸ³ï¼šæ­£ç¡®é¡¹æ˜¯æ­£ç¡®æ‹¼éŸ³
                        if (ST.currentPinyin) {
                            word = ST.currentPinyin; // æ˜¾ç¤ºæ‹¼éŸ³
                            pinyin = ST.currentPinyin;
                        } else {
                            type = 'obstacle';
                        }
                    } else {
                        // éŸ³æ‰¾å­—ï¼šæ­£ç¡®é¡¹æ˜¯æ­£ç¡®æ±‰å­—
                        if (ST.currentCorrectWord) {
                            word = ST.currentCorrectWord;
                            pinyin = ST.currentPinyin;
                        } else {
                            type = 'obstacle';
                        }
                    }
                }

                // é€‰æ‹©è·‘é“ï¼ˆä¸åœ¨åŒä¸€è·‘é“æ”¾ç›¸åŒå¹²æ‰°é¡¹ï¼‰
                let track = Math.floor(Math.random() * 3);
                const existingOnTrack = ST.objects.filter(o => o.track === track && o.y < VP.y + 100);
                if (existingOnTrack.length > 0) track = (track + 1) % 3;

                ST.objects.push({
                    type, track, y: VP.y, word, pinyin,
                    alive: true, scale: 0.08
                });
            }

            function updateObjects() {
                const diff = getDifficulty();
                const py = H * CFG.physics.playerY;

                for (let i = ST.objects.length - 1; i >= 0; i--) {
                    const o = ST.objects[i];
                    // v2.8: è·‘åŠ¨æ—¶é€Ÿåº¦åŠ å€
                    const speed = diff.speed * ST.runSpeedMultiplier;
                    o.y += speed;
                    o.scale = perspScale(o.y);

                    // ç¢°æ’æ£€æµ‹
                    if (o.alive && o.y > py - 40 && o.y < py + 20) {
                        const ox = trackX(o.track, o.y);
                        const px = trackX(ST.trackIndex, py);
                        const dist = Math.abs(ox - px);

                        if (dist < 30 * o.scale) {
                            // ç©å®¶åœ¨è·³è·ƒä¸­ â†’ è·³è¿‡
                            if (!ST.isGrounded && ST.playerJump > 30) {
                                // è·³è¿‡ä¸è§¦å‘ç¢°æ’ï¼Œä¸åŠ åˆ†
                            } else {
                                handleCollision(o);
                            }
                            o.alive = false;
                        }
                    }

                    // ç§»å‡ºå±å¹•
                    if (o.y > H + 50) {
                        ST.objects.splice(i, 1);
                    }
                }
            }

            function drawObjects() {
                ST.objects.forEach(o => {
                    if (!o.alive) return;
                    const x = trackX(o.track, o.y);
                    let s = o.scale;

                    if (o.type === 'obstacle') s = s * CFG.physics.obstacleScale;

                    ctx.save();
                    ctx.translate(x, o.y);

                    if (o.type === 'obstacle') {
                        // v3.3: åšç‰›çš®çº¸ç®±æ¿ç«‹ç‰Œ (Thick Corrugated Cardboard)
                        const w = 50 * s;
                        const h = 40 * s;

                        // é˜´å½±
                        ctx.shadowColor = 'rgba(0,0,0,0.4)'; ctx.shadowOffsetY = 5 * s; ctx.shadowBlur = 6 * s;

                        // 1. ç«‹ç‰Œåº•åº§ (æ·±è‰²ç¡¬çº¸æ¿)
                        ctx.fillStyle = '#5d4037';
                        ctx.fillRect(-w / 2, h / 2 - 4 * s, w, 6 * s);

                        // 2. å‰ªçº¸ä¸»ä½“ (æ³¢æµªå½¢/ç«ç„°å½¢)
                        ctx.beginPath();
                        const points = [];
                        const steps = 8;
                        const stepW = w / steps;

                        // å·¦ä¸‹è§’
                        points.push({ x: -w / 2, y: h / 2 - 4 * s });

                        // ä¸Šè¾¹ç¼˜æ³¢æµª (æ›´åœ†æ¶¦)
                        for (let i = 0; i <= steps; i++) {
                            const px = -w / 2 + i * stepW;
                            const py = -h / 2 + Math.sin(i * 0.8 + o.y * 0.1) * 8 * s + (i % 2 == 0 ? 2 * s : -2 * s);
                            points.push({ x: px, y: py });
                        }

                        // å³ä¸‹è§’
                        points.push({ x: w / 2, y: h / 2 - 4 * s });

                        // é—­åˆå¹¶å¡«å……
                        ctx.moveTo(points[0].x, points[0].y);
                        for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                        ctx.closePath();

                        // å¡«å……: ç‰›çš®çº¸æ¸å˜
                        const grad = ctx.createLinearGradient(0, -h, 0, h);
                        grad.addColorStop(0, '#e67e22'); // äº®æ©™
                        grad.addColorStop(1, '#d35400'); // æ·±æ©™
                        ctx.fillStyle = grad;
                        ctx.fill();

                        // 3. å¢åŠ åšåº¦ (ä¾§é¢ 3D)
                        ctx.shadowColor = 'transparent';
                        ctx.fillStyle = '#8d6e63'; // ä¾§é¢æ·±è¤è‰²
                        ctx.beginPath();
                        const thickness = 6 * s;
                        for (let i = 1; i < points.length; i++) {
                            ctx.moveTo(points[i - 1].x, points[i - 1].y);
                            ctx.lineTo(points[i].x, points[i].y);
                            ctx.lineTo(points[i].x + thickness, points[i].y + thickness * 0.5);
                            ctx.lineTo(points[i - 1].x + thickness, points[i - 1].y + thickness * 0.5);
                        }
                        ctx.fill();

                        // 4. ç“¦æ¥çº¸çº¹ç† (å†…éƒ¨çº¹ç†)
                        ctx.strokeStyle = 'rgba(0,0,0,0.15)'; // æ·±è‰²å‹ç—•
                        ctx.lineWidth = 2 * s;
                        ctx.beginPath();
                        // ç«–å‘æ¡çº¹
                        const stripeCount = 6;
                        const stripeGap = w / stripeCount;
                        for (let i = 1; i < stripeCount; i++) {
                            const sx = -w / 2 + i * stripeGap;
                            if (sx < w / 2 - 5 * s) { // ç®€å•è£å‰ª
                                ctx.moveTo(sx, -h / 2 + 10 * s);
                                ctx.lineTo(sx, h / 2 - 6 * s);
                            }
                        }
                        ctx.stroke();

                        // æè´¨å™ªç‚¹
                        ctx.fillStyle = 'rgba(255,255,255,0.1)';
                        for (let k = 0; k < 20; k++) {
                            ctx.fillRect(-w / 2 + Math.random() * w, -h / 2 + Math.random() * h, 2, 2);
                        }

                        // è­¦å‘Šæ ‡è¯† (å–·æ¼†/å°ç« æ•ˆæœ)
                        const triSz = 12 * s;
                        const triY = 2 * s;
                        ctx.fillStyle = 'rgba(50, 50, 50, 0.8)'; // é»‘å¢¨æ°´
                        ctx.beginPath();
                        ctx.moveTo(0, triY - triSz);
                        ctx.lineTo(-triSz * 0.8, triY + triSz * 0.6);
                        ctx.lineTo(triSz * 0.8, triY + triSz * 0.6);
                        ctx.fill();

                        // æ„Ÿå¹å·
                        ctx.fillStyle = '#e67e22'; // é•‚ç©º
                        ctx.font = `bold ${14 * s}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText('!', 0, triY + triSz * 0.4);

                    } else {
                        // v3.2: ç»Ÿä¸€ä¸è§„åˆ™æ·±é»„è‰²æ–¹å½¢ä¾¿ç­¾ (Irregular Dark Yellow Square)
                        const sz = 36 * s;

                        ctx.shadowColor = 'rgba(0,0,0,0.3)';
                        ctx.shadowOffsetY = 4 * s;
                        ctx.shadowBlur = 3 * s;

                        // æ·±é»„è‰²
                        ctx.fillStyle = '#f1c40f'; // Vivid Yellow/Orange-Yellow

                        // ç¨å¾®æ—‹è½¬
                        const rot = ((o.y * 100) % 10 - 5) * 0.02;
                        ctx.rotate(rot);

                        const w = sz * 1.3;
                        const h = sz * 1.3;

                        const points = [
                            { x: -w / 2, y: -h / 2 },
                            { x: w / 2, y: -h / 2 },
                            { x: w / 2, y: h / 2 },
                            { x: -w / 2, y: h / 2 },
                            { x: -w / 2, y: -h / 2 }
                        ];
                        drawRoughPath(ctx, points, true);
                        ctx.fill();

                        // çº¸å¼ çº¹ç† (å¢åŠ å™ªç‚¹)
                        ctx.fillStyle = 'rgba(0,0,0,0.05)';
                        for (let k = 0; k < 10; k++) {
                            ctx.fillRect(-w / 2 + Math.random() * w, -h / 2 + Math.random() * h, 2, 2);
                        }

                        ctx.shadowColor = 'transparent';
                        ctx.strokeStyle = '#d4ac0d'; // Darker border
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // æ±‰å­— (å¢¨æ°´é£)
                        ctx.fillStyle = '#2d3436';
                        ctx.font = `bold ${24 * s}px "Microsoft YaHei"`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(o.word, 0, 0);

                        // æ‹¼éŸ³ (å·²ç§»é™¤)
                    }
                    ctx.restore();
                });
            }

            // ===== ç¢°æ’å¤„ç† =====
            function handleCollision(o) {
                // v2.8.6: é€šå…³åŠ¨ç”»æœŸé—´æ— æ•Œ
                if (ST.isCompletingLevel && o.type !== 'correct') return;
                if (CFG.ui.isInvincible && o.type !== 'correct') return;

                if (o.type === 'obstacle') {
                    ST.lives -= CFG.rules.obstacleDamage;
                    ST.score += (CFG.scoring.hitObstacle || 0); // æ‰£åˆ†
                    SFX.hit();
                    ST.combo = 0; ST.wrongStreak = 0;
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff3c3c', 15);
                } else if (o.type === 'wrong') {
                    ST.lives -= CFG.rules.wrongDamage;
                    ST.score += (CFG.scoring.hitDistractor || 0); // æ‰£åˆ†
                    SFX.wrong();
                    ST.combo = 0;
                    ST.wrongStreak++;
                    ST.correctStreak = 0;
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff6b6b', 10);
                } else if (o.type === 'correct') {
                    ST.combo++;
                    if (ST.combo > ST.maxCombo) ST.maxCombo = ST.combo;
                    // v4.1: åŸºç¡€å¾—åˆ† + è¿å‡»å¥–åŠ±æŸ¥è¡¨
                    ST.score += CFG.scoring.correctBase;
                    if (ST.combo >= 2 && CFG.scoring.comboRewards) {
                        const comboKey = Math.min(ST.combo, CFG.scoring.comboMax || 5);
                        const reward = CFG.scoring.comboRewards[comboKey] || 0;
                        ST.score += reward;
                    }
                    ST.correctTotal++;
                    ST.correctStreak++;
                    ST.wrongStreak = 0;
                    // v4.1: æ’­æ”¾éŸ³é¢‘ï¼ˆéŸ³æ‰¾å­—æ’­æ±‰å­—ï¼Œå­—æ‰¾éŸ³æ’­æ‹¼éŸ³ï¼‰
                    if (ST.gamePhase === 'wordToSound') {
                        SFX.correct({ word: ST.currentPinyin }); // æ’­æ‹¼éŸ³
                    } else {
                        SFX.correct({ pinyin: ST.currentPinyin, word: o.word });
                    }
                    spawnParticles(trackX(o.track, o.y), o.y, '#00ffcc', 25);
                    spawnParticles(trackX(o.track, o.y), o.y, '#ffd700', 15);
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff69b4', 10);
                }

                // v4.1: è¿å‡»ç²’å­æ•ˆæœ
                if (ST.combo >= 2) {
                    ST.comboDisplayTimer = 0.8;
                    // ç”Ÿæˆé‡‘è‰²ç²’å­åœ¨è¿å‡»æ–‡å­—ä½ç½®
                    const comboX = W / 2;
                    const comboY = H * 0.42;
                    for (let i = 0; i < 8; i++) {
                        ST.particles.push({
                            x: comboX + (Math.random() - 0.5) * 60,
                            y: comboY + (Math.random() - 0.5) * 30,
                            vx: (Math.random() - 0.5) * 6,
                            vy: (Math.random() - 0.5) * 6 - 2,
                            life: 1, decay: 0.02 + Math.random() * 0.02,
                            size: 3 + Math.random() * 4,
                            color: Math.random() > 0.5 ? '#ffd700' : '#ff9500',
                            type: 'star'
                        });
                    }
                }

                updateHUD();
                checkLevelState();
            }

            // ===== å…³å¡æ£€æŸ¥ =====
            function checkLevelState() {
                if (ST.lives <= 0) {
                    endGame(); return;
                }
                // è¿å‡»4ä¸ªé”™è¯¯ â†’ å¤±è´¥
                if (ST.wrongStreak >= CFG.rules.failWrongStreak) {
                    endGame(); return;
                }
                // ç´¯è®¡9ä¸ªæ­£ç¡® æˆ– è¿ç»­4ä¸ªæ­£ç¡® â†’ è¿‡å…³
                // v2.8.6: å»¶è¿Ÿé€šå…³é€»è¾‘
                const isWin = ST.correctTotal >= CFG.rules.winCorrectTotal || ST.correctStreak >= CFG.rules.winCorrectStreak;

                if (isWin && !ST.isCompletingLevel) {
                    // å¼€å§‹é€šå…³æµç¨‹ï¼šå…‰ç¯åŠ¨ç”» -> å»¶è¿Ÿ -> å¼¹çª—
                    ST.isCompletingLevel = true;
                    ST.ringCompleteAnim = 1.0; // è§¦å‘å¤–ç¯é—ªçƒåŠ¨ç”»
                    SFX.levelUp(); // æ’­æ”¾éŸ³æ•ˆ

                    // 1.5ç§’åæ˜¾ç¤ºç»“ç®—ç•Œé¢
                    setTimeout(() => {
                        clearLevel();
                    }, 1500);
                }
            }

            function clearLevel() {
                ST.paused = true;
                ST.totalLevelsCleared++;
                ST.streakLevels++;

                SFX.levelUp();

                // v2.8: ç´¯åŠ å·²å®Œæˆçš„å­—æ•°
                ST.completedWordCount++;

                // v2.8.2: ä¿®æ­£é€šå…³ç®€æŠ¥æ˜¾ç¤º
                const lcInfo = document.getElementById('lc-info');
                const justPassedLevel = ST.levelIndex + 1;

                // é€šå…³æ ‡é¢˜
                const phaseLabel = ST.gamePhase === 'wordToSound' ? 'å­—æ‰¾éŸ³' : 'éŸ³æ‰¾å­—';
                document.querySelector('#level-clear h2').textContent = `${phaseLabel} ç¬¬${justPassedLevel}å…³ é€šè¿‡ï¼`;

                // ä»»åŠ¡ç®€æŠ¥
                const taskDisplay = ST.gamePhase === 'wordToSound'
                    ? `${ST.currentCorrectWord} â†’ ${ST.currentPinyin}`
                    : `${ST.currentPinyin} â†’ ${ST.currentCorrectWord}`;
                lcInfo.innerHTML = `ä»»åŠ¡ï¼š${taskDisplay}<br>æ­£ç¡®ï¼š${ST.correctTotal}ä¸ª | è¿å‡»ï¼š${ST.maxCombo}<br>å¾—åˆ†ï¼š${ST.score}åˆ†<br>ç­‰çº§ï¼š${getLevel(ST.score).rank}`;

                document.getElementById('level-clear').style.display = 'flex';
            }

            function nextLevel() {
                document.getElementById('level-clear').style.display = 'none';
                ST.levelIndex++;
                const currentList = ST.gamePhase === 'wordToSound' ? wordList : pinyinList;
                if (ST.levelIndex >= currentList.length) {
                    if (ST.gamePhase === 'soundToWord') {
                        // éŸ³æ‰¾å­—å®Œæˆï¼Œæ˜¾ç¤ºè¿‡æ¸¡å¼¹çª—
                        ST.paused = true;
                        document.getElementById('phase-transition').style.display = 'flex';
                        return;
                    } else {
                        // å­—æ‰¾éŸ³ä¹Ÿå®Œæˆï¼Œæ¸¸æˆç»“æŸ
                        endGame(true); return;
                    }
                }
                startLevel();
            }

            function startLevel() {
                ST.levelTime = 0; ST.correctTotal = 0; ST.correctStreak = 0; ST.wrongStreak = 0; ST.combo = 0; ST.maxCombo = 0;
                ST.comboDisplayTimer = 0;
                ST.isCompletingLevel = false;
                ST.objects = []; ST.particles = [];
                ST.appearedCorrectWords.clear();

                if (ST.gamePhase === 'wordToSound') {
                    // å­—æ‰¾éŸ³ï¼šä»»åŠ¡åŒºæ˜¾ç¤ºæ±‰å­—ï¼Œè·‘é“å‡ºç°æ‹¼éŸ³
                    ST.currentCorrectWord = wordList[ST.levelIndex];
                    const matches = getAllData().filter(d => d.word === ST.currentCorrectWord);
                    ST.currentPinyin = matches.length > 0 ? matches[0].pinyin : '';
                    ST.currentTaskDisplay = ST.currentCorrectWord;
                    ST.currentWord = ST.currentCorrectWord;
                } else {
                    // éŸ³æ‰¾å­—ï¼šä»»åŠ¡åŒºæ˜¾ç¤ºæ‹¼éŸ³ï¼Œè·‘é“å‡ºç°æ±‰å­—
                    ST.currentPinyin = pinyinList[ST.levelIndex];
                    const matches = getAllData().filter(d => d.pinyin === ST.currentPinyin);
                    if (matches.length > 0) {
                        const selectedItem = matches[Math.floor(Math.random() * matches.length)];
                        ST.currentCorrectWord = selectedItem.word;
                        ST.currentWord = selectedItem.word;
                    } else {
                        ST.currentCorrectWord = '';
                        ST.currentWord = ST.currentPinyin;
                    }
                    ST.currentTaskDisplay = ST.currentPinyin;
                }

                ST.paused = false;
                ST.levelTimer = 0;
                updateHUD();
                // ä»»åŠ¡æç¤ºéŸ³
                setTimeout(() => speakWord(ST.currentCorrectWord || ST.currentPinyin), 300);
            }

            function endGame(allClear) {
                ST.gameOver = true; ST.running = false;
                if (!allClear) ST.failedLevelIndex = ST.levelIndex; // v2.8: è®°å½•å¤±è´¥çš„å…³å¡ç´¢å¼•
                stopBGM();
                if (!allClear) SFX.gameOver(); else SFX.levelUp();
                const stats = document.getElementById('go-stats');
                const title = document.querySelector('#game-over h2');
                title.textContent = allClear ? 'ğŸ‰ å…¨éƒ¨é€šå…³ï¼' : 'æ¸¸æˆç»“æŸ';
                title.style.color = allClear ? '#00ffcc' : '#ff6b6b';
                // v2.8.1: ä¿®å¤æ¸¸æˆç»“æŸç»Ÿè®¡ä¿¡æ¯ï¼Œæ˜¾ç¤ºæ­£ç¡®çš„è¿›åº¦
                const currentProgress = `${ST.completedWordCount}/${getAllData().length}`; // å½“å‰å·²å®Œæˆçš„å­—æ•°
                const currentLevel = `ç¬¬${ST.levelIndex + 1}å…³`; // å½“å‰å…³å¡
                stats.innerHTML = `å½“å‰è¿›åº¦ï¼š${currentProgress}<br>å½“å‰å°å…³ï¼š${currentLevel}<br>æ€»å¾—åˆ†ï¼š${ST.score}<br>æœ€é«˜è¿å‡»ï¼š${ST.maxCombo}<br>ç­‰çº§ï¼š${getLevel(ST.score).rank}`;
                document.getElementById('game-over').style.display = 'flex';
            }

            function restartGame() {
                document.getElementById('game-over').style.display = 'none';
                ST.lives = CFG.rules.initLives; ST.score = 0; ST.combo = 0; ST.maxCombo = 0;
                // v2.8: ä»å¤±è´¥çš„å…³å¡é‡æ–°å¼€å§‹ï¼Œä¿æŒè¿›åº¦
                if (ST.failedLevelIndex >= 0) {
                    ST.levelIndex = ST.failedLevelIndex;
                } else {
                    ST.levelIndex = 0;
                    ST.completedWordCount = 0;
                    ST.gamePhase = 'soundToWord'; // é‡ç½®ä¸ºéŸ³æ‰¾å­—é˜¶æ®µ
                }
                ST.totalLevelsCleared = 0; ST.streakLevels = 0;
                ST.objects = []; ST.particles = []; ST.roadLines = [];
                ST.appearedCorrectWords.clear();
                ST.lastTime = 0;
                ST.gameOver = false; ST.running = true; ST.paused = false;
                if (ST.failedLevelIndex < 0) {
                    shuffleArray(pinyinList);
                    shuffleArray(wordList);
                }
                startLevel();
                startBGM();
            }

            // ===== HUD æ›´æ–° =====
            function updateHUD() {
                // åˆ†æ•° & ç”Ÿå‘½
                // ç”Ÿå‘½å€¼ (æ”¯æŒåŠå¿ƒ)
                let hearts = '';
                const full = Math.floor(ST.lives);
                const half = ST.lives % 1 >= 0.5 ? 1 : 0;
                const empty = Math.max(0, CFG.rules.initLives - full - half);
                for (let i = 0; i < full; i++) hearts += 'â¤ï¸';
                if (half) hearts += 'ğŸ’”';
                for (let i = 0; i < empty; i++) hearts += 'ğŸ–¤';
                document.getElementById('hud-hearts').textContent = hearts;

                // æ—¶é—´
                const remaining = Math.max(0, Math.ceil(CFG.rules.levelTime - ST.levelTime));
                document.getElementById('hud-timer').textContent = remaining + 's';
                document.getElementById('hud-timer').style.color = remaining <= 10 ? '#ff3c3c' : '#ff6b6b';

                // ä»»åŠ¡
                document.getElementById('hud-task').textContent = `ä»»åŠ¡ï¼š${ST.currentPinyin}`;

                // åˆ†æ•°
                document.getElementById('hud-score').textContent = ST.score + 'åˆ†';

                // ç­‰çº§
                const lv = getLevel(ST.score);
                const lvIdx = CFG.levels.indexOf(lv) + 1;
                document.getElementById('hud-level').textContent = `Lv.${lvIdx} ${lv.rank}`;

                // v2.8.6: è¿å‡»æç¤ºä¼˜åŒ–ï¼ˆå¸¦åŠ¨ç”»ï¼‰
                const comboEl = document.getElementById('hud-combo');
                if (ST.combo >= 2 && ST.comboDisplayTimer > 0) {
                    comboEl.textContent = `ğŸ”¥ ${ST.combo}è¿å‡»ï¼`;
                    comboEl.classList.remove('fade-out');
                    comboEl.style.opacity = '1';
                } else {
                    comboEl.classList.add('fade-out');
                    // opacityç”±CSSå¤„ç†
                }
            }

            // ===== ç‰©ä½“ç”Ÿæˆè®¡æ—¶å™¨ =====
            let spawnTimer = 0;
            function updateSpawner(dt) {
                const diff = getDifficulty();
                spawnTimer += dt * 1000;
                if (spawnTimer >= diff.interval) {
                    spawnObject();
                    spawnTimer = 0;
                }
            }

            // ===== ä¸»å¾ªç¯ =====
            function gameLoop(timestamp) {
                requestAnimationFrame(gameLoop);
                if (!ST.running) return;
                if (ST.lastTime === 0) ST.lastTime = timestamp;
                const dt = Math.min((timestamp - ST.lastTime) / 1000, 0.05);
                ST.lastTime = timestamp; ST.frameCount++;
                if (ST.paused) return;

                // å…³å¡è®¡æ—¶
                // å…³å¡è®¡æ—¶
                // v2.8.6: é€šå…³åŠ¨ç”»æœŸé—´åœæ­¢è®¡æ—¶
                if (!ST.isCompletingLevel) {
                    ST.levelTime += dt;
                    if (ST.levelTime >= CFG.rules.levelTime) {
                        endGame(); return;
                    }
                }

                // v2.8.6: æ›´æ–°è¿å‡»è®¡æ—¶å™¨
                if (ST.comboDisplayTimer > 0) {
                    ST.comboDisplayTimer -= dt;
                    if (ST.comboDisplayTimer <= 0) updateHUD(); // è§¦å‘æ¶ˆå¤±åŠ¨ç”»
                }

                // v2.8.3: æ£€æµ‹é•¿æŒ‰å¹¶æ›´æ–°è·‘åŠ¨çŠ¶æ€
                updateRunningState();

                // v2.8: è§’è‰²åŠ¨ç”»ï¼ˆè·‘åŠ¨æ¯”èµ°åŠ¨å¿«ï¼‰
                const animSpeed = ST.isRunning ? 0.2 : 0.12;
                ST.playerAnim += animSpeed;

                // è·³è·ƒç‰©ç† update (åŸºäºåŠ›å­¦æ­¥åŠ¨ï¼Œä¸ä½¿ç”¨ dt)
                if (!ST.isGrounded) {
                    ST.playerJump -= ST.vy; // é€Ÿåº¦åº”ç”¨åˆ°é«˜åº¦åç§»
                    ST.vy += CFG.physics.gravity; // é‡åŠ›åŠ é€Ÿåº¦åº”ç”¨åˆ°é€Ÿåº¦

                    // è½åœ°æ£€æµ‹
                    if (ST.playerJump <= 0) {
                        ST.playerJump = 0;
                        ST.vy = 0;
                        ST.isGrounded = true;
                        // è½åœ°ç‰¹æ•ˆ
                        SFX.hit();
                        spawnParticles(trackX(ST.trackIndex, H * CFG.physics.playerY), H * CFG.physics.playerY, '#fff', 5);
                        ST.landingScale = 0.6; // è§¦å‘æŒ¤å‹åŠ¨ç”»
                    }
                }

                // æ›´æ–°
                updateRoadLines();
                updateSpawner(dt);
                updateObjects();
                updateParticles();
                updateHUD();

                // ç»˜åˆ¶
                ctx.clearRect(0, 0, W, H);
                drawTrack();
                drawGameTitle();
                drawTaskRing();
                drawJumpTrajectory();
                drawObjects();
                drawPlayer();
                drawParticles();
            }

            // v2.8.3: è·³è·ƒ (ç‰©ç†é©±åŠ¨ï¼Œæ”¯æŒåŸåœ°è·³å’Œè·‘åŠ¨è·³)
            function jumpPlayer(isRunJump = false) {
                if (!ST.isGrounded || !ST.running || ST.paused) return;
                ST.isGrounded = false;
                // è·‘åŠ¨ä¸­è·³è·ƒåŠ›åº¦æ›´å¤§
                ST.vy = -(isRunJump ? CFG.physics.jumpForce * 1.3 : CFG.physics.jumpForce);
                SFX.jump();
            }

            // ===== è½¦é“åˆ‡æ¢ =====
            function movePlayer(dir) {
                if (!ST.running || ST.paused) return;
                ST.trackIndex = Math.max(0, Math.min(2, ST.trackIndex + dir));
            }

            // ===== æš‚åœ =====
            function togglePause() {
                if (!ST.running || ST.gameOver) return;
                ST.paused = !ST.paused;
                document.getElementById('hud-task').textContent = ST.paused ? 'â¸ å·²æš‚åœ' : `å¯»æ‰¾æ‹¼éŸ³ï¼š${ST.currentPinyin}`;
            }

            // v2.8.3: æŒ‰é”®çŠ¶æ€è·Ÿè¸ªï¼ˆç”¨äºå•å‡»/é•¿æŒ‰/åŒå‡»æ£€æµ‹ï¼‰
            let lastUpKeyTime = 0;
            let upKeyPressed = false;
            let upKeyPressTime = 0;
            const LONG_PRESS_THRESHOLD = 200; // é•¿æŒ‰é˜ˆå€¼ï¼ˆæ¯«ç§’ï¼‰
            const DOUBLE_CLICK_THRESHOLD = 300; // åŒå‡»é˜ˆå€¼ï¼ˆæ¯«ç§’ï¼‰

            // ===== é”®ç›˜è¾“å…¥ =====
            document.addEventListener('keydown', e => {
                if (e.code === 'ArrowUp' && !upKeyPressed) {
                    upKeyPressed = true;
                    upKeyPressTime = Date.now();
                    e.preventDefault();
                } else if (e.code === 'ArrowLeft') {
                    movePlayer(-1); e.preventDefault();
                } else if (e.code === 'ArrowRight') {
                    movePlayer(1); e.preventDefault();
                } else if (e.code === 'Space') {
                    togglePause(); e.preventDefault();
                }
            });

            document.addEventListener('keyup', e => {
                if (e.code === 'ArrowUp' && upKeyPressed) {
                    const now = Date.now();
                    const pressDuration = now - upKeyPressTime;
                    upKeyPressed = false;

                    // åˆ¤æ–­æ˜¯å¦ä¸ºé•¿æŒ‰ï¼ˆè·‘åŠ¨ï¼‰
                    if (pressDuration >= LONG_PRESS_THRESHOLD) {
                        // é•¿æŒ‰ç»“æŸï¼Œåœæ­¢è·‘åŠ¨
                        ST.isRunning = false;
                        ST.runSpeedMultiplier = 1.0;
                    } else {
                        // å¿«é€Ÿå•å‡»
                        // æ£€æŸ¥æ˜¯å¦ä¸ºåŒå‡»ï¼ˆåœ¨è·‘åŠ¨çŠ¶æ€ä¸‹çš„åŒå‡»è·³è·ƒï¼‰
                        if (ST.isRunning && now - lastUpKeyTime < DOUBLE_CLICK_THRESHOLD) {
                            // è·‘åŠ¨ä¸­åŒå‡» = è·‘åŠ¨è·³è·ƒ
                            jumpPlayer(true);
                            lastUpKeyTime = 0;
                        } else {
                            // å•å‡» = åŸåœ°è·³è·ƒ
                            jumpPlayer(false);
                            lastUpKeyTime = now;
                        }
                    }
                }
            });

            // v2.8.3: æ£€æµ‹é•¿æŒ‰å¹¶è§¦å‘è·‘åŠ¨
            function updateRunningState() {
                if (upKeyPressed && !ST.isRunning) {
                    const pressDuration = Date.now() - upKeyPressTime;
                    if (pressDuration >= LONG_PRESS_THRESHOLD) {
                        ST.isRunning = true;
                        ST.runSpeedMultiplier = 2.0;
                    }
                }
                // æ›´æ–°è·‘åŠ¨åŠ¨ç”»
                if (ST.isRunning && !ST.paused) {
                    ST.runAnimPhase = (ST.runAnimPhase + 0.2) % (Math.PI * 2);
                }
            }

            // ===== è§¦æ‘¸æ‰‹åŠ¿ =====
            let touchStartX = 0, touchStartY = 0, touchStartTime = 0, lastTapTime = 0, lastUpTapTime = 0;
            document.addEventListener('touchstart', e => {
                const t = e.touches[0]; touchStartX = t.clientX; touchStartY = t.clientY; touchStartTime = Date.now();
                e.preventDefault();
            }, { passive: false });
            document.addEventListener('touchend', e => {
                const t = e.changedTouches[0];
                const dx = t.clientX - touchStartX, dy = t.clientY - touchStartY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const elapsed = Date.now() - touchStartTime;

                if (dist < 20 && elapsed < 300) {
                    // ç‚¹å‡» â†’ æ£€æŸ¥åŒå‡»
                    const now = Date.now();
                    if (now - lastTapTime < 350) { togglePause(); lastTapTime = 0; }
                    else lastTapTime = now;
                } else if (dist > 30) {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        dx < 0 ? movePlayer(-1) : movePlayer(1);
                    } else if (dy < -30) {
                        // v2.8: å‘ä¸Šæ»‘åŠ¨ - æ£€æµ‹åŒå‡»è·³è·ƒ vs å•å‡»è·‘åŠ¨
                        const now = Date.now();
                        if (now - lastUpTapTime < 300) {
                            jumpPlayer();
                            lastUpTapTime = 0;
                        } else {
                            ST.isRunning = true;
                            ST.runSpeedMultiplier = 2.0;
                            lastUpTapTime = now;
                            // 0.5ç§’åè‡ªåŠ¨æ¢å¤èµ°åŠ¨
                            setTimeout(() => {
                                ST.isRunning = false;
                                ST.runSpeedMultiplier = 1.0;
                            }, 500);
                        }
                    }
                }
                e.preventDefault();
            }, { passive: false });


            // ===== å¯åŠ¨ =====
            // é¡µé¢åŠ è½½æ—¶åŠ è½½ä¿å­˜çš„é…ç½®
            loadConfig();
            // v2.9.1: åŒæ­¥ ST.livesï¼ˆloadConfig åœ¨ ST åˆå§‹åŒ–ä¹‹åæ‰§è¡Œï¼Œéœ€æ‰‹åŠ¨åŒæ­¥ï¼‰
            ST.lives = CFG.rules.initLives;
            // v4.0: loadConfig å¯èƒ½æ³¨å…¥äº†æ–°çš„ CSV æ•°æ®ï¼Œåˆ·æ–°åˆ—è¡¨
            // v4.2: ä»»åŠ¡æ€»æ•°ç­‰äº offlineData æ€»æ•°ï¼ˆä¸å»é‡ï¼‰
            pinyinList = CFG.dataSource.offlineData.map(d => d.pinyin);
            wordList = CFG.dataSource.offlineData.map(d => d.word);

            document.getElementById('start-btn').onclick = () => {
                const ss = document.getElementById('start-screen');
                ss.style.opacity = '0';
                setTimeout(() => ss.remove(), 600);
                ensureAudio();
                // é¢„çƒ­ TTS
                const v = new SpeechSynthesisUtterance(''); v.volume = 0; window.speechSynthesis.speak(v);
                startBGM();
                ST.running = true;
                startLevel();
                requestAnimationFrame(gameLoop);
            };

            document.getElementById('go-restart').onclick = restartGame;
            document.getElementById('lc-next').onclick = nextLevel;

            // v4.1: éŸ³æ‰¾å­—â†’å­—æ‰¾éŸ³ é˜¶æ®µåˆ‡æ¢
            document.getElementById('phase-next-btn').onclick = () => {
                document.getElementById('phase-transition').style.display = 'none';
                ST.gamePhase = 'wordToSound';
                ST.levelIndex = 0;
                ST.completedWordCount = 0;
                ST.failedLevelIndex = -1;
                shuffleArray(wordList);
                ST.paused = false;
                startLevel();
            };

        })();
    </script>
</body>

</html>