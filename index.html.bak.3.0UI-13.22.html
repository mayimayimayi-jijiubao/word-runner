<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>字跑大师</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a12;
            font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
            touch-action: none;
            user-select: none
        }

        #wrap {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative
        }

        canvas {
            display: block;
            image-rendering: pixelated
        }

        #hud {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            color: #fff;
            z-index: 10
        }

        #hud .row {
            display: flex;
            justify-content: space-between;
            padding: 6px 12px;
            font-size: 13px;
            opacity: .85
        }

        #hud .task {
            display: none
        }

        #hud .hearts {
            font-size: 18px;
            letter-spacing: 2px
        }

        #hud .score {
            font-size: 14px;
            color: #ffd700
        }

        #hud .timer {
            font-size: 14px;
            color: #ff6b6b
        }

        #hud .level {
            font-size: 12px;
            color: #aaa
        }

        #hud .combo {
            position: absolute;
            top: 350px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: #ff0;
            text-shadow: 0 0 8px rgba(255, 255, 0, .5);
            opacity: 0;
            transition: opacity .3s, transform .3s;
            white-space: nowrap;
            pointer-events: none;
        }

        #hud .combo.fade-out {
            opacity: 0 !important;
            transform: translateX(-50%) translateY(-30px);
        }

        #start-screen {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at 50% 40%, #1a1a2e 0%, #0a0a12 100%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity .6s
        }

        #start-screen h1 {
            font-size: 48px;
            color: #00ffcc;
            text-shadow: 0 0 30px rgba(0, 255, 204, .4);
            margin-bottom: 8px;
            letter-spacing: 6px
        }

        #start-screen .sub {
            color: #888;
            font-size: 14px;
            margin-bottom: 40px
        }

        #start-screen button {
            padding: 16px 56px;
            font-size: 20px;
            background: linear-gradient(135deg, #00ffcc, #00cc99);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            color: #003d33;
            box-shadow: 0 0 40px rgba(0, 255, 204, .3);
            transition: transform .2s, box-shadow .2s
        }

        #start-screen button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 60px rgba(0, 255, 204, .5)
        }


        #game-over {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .85);
            z-index: 80;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff
        }

        #game-over h2 {
            font-size: 36px;
            color: #ff6b6b;
            margin-bottom: 16px
        }

        #game-over .stats {
            font-size: 16px;
            line-height: 2;
            text-align: center;
            margin-bottom: 24px
        }

        #game-over button {
            padding: 14px 48px;
            font-size: 18px;
            background: #00ffcc;
            color: #003d33;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold
        }

        #level-clear {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .8);
            z-index: 80;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff
        }

        #level-clear h2 {
            font-size: 32px;
            color: #00ffcc;
            margin-bottom: 12px
        }

        #level-clear .info {
            font-size: 16px;
            line-height: 2;
            text-align: center;
            margin-bottom: 20px
        }

        #level-clear button {
            padding: 12px 40px;
            font-size: 16px;
            background: #00ffcc;
            color: #003d33;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold
        }
    </style>
</head>

<body>
    <div id="start-screen">
        <h1>字跑大师</h1>
        <div class="sub">Word Runner Master</div>
        <button id="start-btn">开始游戏</button>
    </div>
    <div id="wrap">
        <canvas id="gc"></canvas>
        <div id="hud">
            <div class="row"><span class="hearts" id="hud-hearts">❤️❤️❤️</span><span class="timer"
                    id="hud-timer">40s</span></div>
            <div class="task" id="hud-task">准备起跑</div>
            <div class="row"><span class="score" id="hud-score">0分</span><span class="level" id="hud-level">Lv.1
                    识字新兵</span></div>
            <div style="text-align:center"><span class="combo" id="hud-combo"></span></div>
        </div>
    </div>

    <div id="game-over">
        <h2>游戏结束</h2>
        <div class="stats" id="go-stats"></div><button id="go-restart">再来一局</button>
    </div>
    <div id="level-clear">
        <h2 id="lc-title">过关！</h2>
        <div class="info" id="lc-info"></div><button id="lc-next">下一关</button>
    </div>

    <script>
        // ========== 配置块（由 workbench.html 注入）==========
        window.WRM_CONFIG = {
            metadata: { version: "3.0.0", unitTitle: "人教版四年级上册·第一单元", playerName: "贝贝" },
            rules: {
                levelTime: 40,
                winCorrectTotal: 9,
                winCorrectStreak: 4,
                failWrongStreak: 4,
                initLives: 3,
                obstacleDamage: 1,
                wrongDamage: 0.5
            },
            difficulty: {
                speedStart: 2, speedEnd: 6,
                intervalStart: 2000, intervalEnd: 800,
                obstacleStart: 0.10, obstacleEnd: 0.40,
                wrongStart: 0.20, wrongEnd: 0.45,
                correctStart: 0.70, correctEnd: 0.15
            },
            scoring: {
                correctBase: 100, comboMax: 5,
                dodgeObstacle: 20, levelClear: 500,
                timeBonus: 10, streakBonus: 200
            },
            levels: [
                { rank: "识字新兵", threshold: 0 },
                { rank: "拼音学徒", threshold: 1000 },
                { rank: "汉字猎手", threshold: 3000 },
                { rank: "文字侠客", threshold: 6000 },
                { rank: "字跑大师", threshold: 10000 },
                { rank: "传奇字神", threshold: 20000 }
            ],
            physics: {
                tracksX: [0.166666, 0.5, 0.833333], // v2.9.2: 真正三等分跑道（1/6, 1/2, 5/6）
                playerY: 0.90, // 下移至 90%
                gravity: 2000,
                jumpForce: 750,
                objScaleStart: 0.08, // 物体远端缩放
                objScaleEnd: 1.0,     // 物体近端缩放
                playerScale: 1.5,     // 角色固定缩放
                obstacleScale: 1.0    // 障碍物额外缩放
            },
            levelDesign: {
                levelName: "音找字",                    // 关卡名称
                taskSource: "pinyin",                    // 任务区数据来源: pinyin | word
                correctSource: "word",                   // 正确项数据来源: word
                wrongSource: "word_exclude_homophone",   // 干扰项数据来源: word | word_exclude_homophone
                polyphoneRule: "use_data_pinyin",        // 多音字规则: use_data_pinyin | auto
                homophoneRule: "exclusive"               // 同音字规则: exclusive | allow_both
            },
            ui: { themeColor: "#00ffcc", isInvincible: false },
            dataSource: {
                offlineData: [
                    { "word": "潮", "pinyin": "cháo" }, { "word": "盐", "pinyin": "yán" }, { "word": "薄", "pinyin": "bó" },
                    { "word": "屹", "pinyin": "yì" }, { "word": "昂", "pinyin": "áng" }, { "word": "鼎", "pinyin": "dǐng" },
                    { "word": "沸", "pinyin": "fèi" }, { "word": "据", "pinyin": "jù" }, { "word": "堤", "pinyin": "dī" },
                    { "word": "阔", "pinyin": "kuò" }, { "word": "盼", "pinyin": "pàn" }, { "word": "滚", "pinyin": "gǔn" },
                    { "word": "顿", "pinyin": "dùn" }, { "word": "逐", "pinyin": "zhú" }, { "word": "渐", "pinyin": "jiàn" },
                    { "word": "堵", "pinyin": "dǔ" }, { "word": "犹", "pinyin": "yóu" }, { "word": "贯", "pinyin": "guàn" },
                    { "word": "浩", "pinyin": "hào" }, { "word": "崩", "pinyin": "bēng" }, { "word": "震", "pinyin": "zhèn" },
                    { "word": "霎", "pinyin": "shà" }, { "word": "余", "pinyin": "yú" }, { "word": "淘", "pinyin": "táo" },
                    { "word": "牵", "pinyin": "qiān" }, { "word": "鹅", "pinyin": "é" }, { "word": "卵", "pinyin": "luǎn" },
                    { "word": "坑", "pinyin": "kēng" }, { "word": "洼", "pinyin": "wā" }, { "word": "填", "pinyin": "tián" },
                    { "word": "庄", "pinyin": "zhuāng" }, { "word": "稼", "pinyin": "jià" }, { "word": "俗", "pinyin": "sú" },
                    { "word": "跃", "pinyin": "yuè" }, { "word": "葡", "pinyin": "pú" }, { "word": "萄", "pinyin": "táo" },
                    { "word": "稻", "pinyin": "dào" }, { "word": "熟", "pinyin": "shú" }, { "word": "穗", "pinyin": "suì" },
                    { "word": "镀", "pinyin": "dù" }, { "word": "埂", "pinyin": "gěng" }, { "word": "烁", "pinyin": "shuò" },
                    { "word": "巢", "pinyin": "cháo" }, { "word": "苇", "pinyin": "wěi" }, { "word": "罗", "pinyin": "luó" },
                    { "word": "眠", "pinyin": "mián" }, { "word": "霸", "pinyin": "bà" }, { "word": "占", "pinyin": "zhàn" },
                    { "word": "昧", "pinyin": "mèi" }, { "word": "坠", "pinyin": "zhuì" }, { "word": "怀", "pinyin": "huái" }
                ]
            }
        };
        // ========== 配置块结束 ==========

        ; (function () {
            "use strict";
            const CFG = window.WRM_CONFIG;
            const W = 450, H = 800;
            const canvas = document.getElementById('gc');
            const ctx = canvas.getContext('2d');
            canvas.width = W; canvas.height = H;

            // ===== 自适应缩放 =====
            function resize() {
                const ww = window.innerWidth, wh = window.innerHeight;
                const scale = Math.min(ww / W, wh / H);
                canvas.style.width = (W * scale) + 'px';
                canvas.style.height = (H * scale) + 'px';
                const hud = document.getElementById('hud');
                hud.style.width = (W * scale) + 'px';
            }
            window.addEventListener('resize', resize); resize();

            // ===== 音频引擎 =====
            let audioCtx = null;
            function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); }
            function synth(freq, type, decay, vol) {
                ensureAudio();
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
                o.frequency.exponentialRampToValueAtTime(Math.max(freq * 0.01, 1), audioCtx.currentTime + decay);
                g.gain.setValueAtTime(vol, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + decay);
                o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + decay);
            }
            function speakWord(text) {
                if (!('speechSynthesis' in window)) return;
                const u = new SpeechSynthesisUtterance(text); u.lang = 'zh-CN'; u.rate = 0.85;
                window.speechSynthesis.speak(u);
            }
            let bgmNodes = [];
            function startBGM() {
                ensureAudio();
                const master = audioCtx.createGain(); master.gain.value = 0.03; master.connect(audioCtx.destination);
                [110, 165, 220, 330].forEach((f, i) => {
                    const o = audioCtx.createOscillator(); o.type = 'sine'; o.frequency.value = f; o.detune.value = i * 3;
                    o.connect(master); o.start(); bgmNodes.push(o);
                });
            }
            function stopBGM() { bgmNodes.forEach(o => { try { o.stop(); } catch (e) { } }); bgmNodes = []; }
            const SFX = {
                correct(data) {
                    synth(880, 'sine', 0.15, 0.25); synth(1100, 'sine', 0.2, 0.15);
                    // v2.8: 撞击正确项时只播放汉字读音
                    if (data.word) setTimeout(() => speakWord(data.word), 150);
                },
                wrong() { synth(150, 'sawtooth', 0.3, 0.2); synth(120, 'square', 0.2, 0.15); },
                hit() { synth(80, 'square', 0.15, 0.3); },
                jump() { synth(400, 'sine', 0.1, 0.1); synth(600, 'sine', 0.08, 0.08); },
                levelUp() { synth(523, 'sine', 0.2, 0.2); setTimeout(() => synth(659, 'sine', 0.2, 0.2), 150); setTimeout(() => synth(784, 'sine', 0.3, 0.2), 300); },
                gameOver() { synth(300, 'sawtooth', 0.5, 0.2); synth(200, 'sawtooth', 0.6, 0.15); }
            };

            // ===== 游戏状态 =====
            const ST = {
                running: false, paused: false, gameOver: false,
                lives: CFG.rules.initLives, score: 0, combo: 0, maxCombo: 0,
                levelIndex: 0, levelTime: 0, levelTimer: 0,
                correctTotal: 0, correctStreak: 0, wrongStreak: 0,
                currentPinyin: '', currentWord: '', currentCorrectWord: '', // v2.8: 本关唯一正确汉字
                trackIndex: 1, playerJump: 0, jumpVy: 0, isJumping: false, playerAnim: 0,
                landingScale: 1.0, // 落地挤压缩放
                isRunning: false, runSpeedMultiplier: 1.0, // v2.8: 跑动状态和速度倍率
                runAnimPhase: 0, // v2.8.3: 跑动动画阶段
                objects: [], particles: [], roadLines: [],
                streakLevels: 0, totalLevelsCleared: 0,
                completedWordCount: 0, // v2.8: 已完成的字数（用于显示总进度）
                failedLevelIndex: -1, // v2.8: 失败时的关卡索引
                ringCompleteAnim: 0, // v2.8: 外环完成动画进度
                appearedCorrectWords: new Set(), // v2.5: 跟踪已出现的同音字
                dt: 0, lastTime: 0, frameCount: 0
            };

            // ===== 关卡数据 =====
            const allData = CFG.dataSource.offlineData;
            let pinyinList = [...new Set(allData.map(d => d.pinyin))];

            // ===== 等级计算 =====
            function getLevel(score) {
                let lv = CFG.levels[0];
                for (const l of CFG.levels) { if (score >= l.threshold) lv = l; }
                return lv;
            }

            // ===== 难度曲线 =====
            function getDifficulty() {
                const t = Math.min(ST.levelTime / CFG.rules.levelTime, 1);
                const d = CFG.difficulty;
                const lerp = (a, b) => a + (b - a) * t;
                return {
                    speed: lerp(d.speedStart, d.speedEnd),
                    interval: lerp(d.intervalStart, d.intervalEnd),
                    pObstacle: lerp(d.obstacleStart, d.obstacleEnd),
                    pWrong: lerp(d.wrongStart, d.wrongEnd),
                    pCorrect: lerp(d.correctStart, d.correctEnd)
                };
            }

            // ===== localStorage 配置管理 =====
            function loadConfig() {
                try {
                    const saved = localStorage.getItem('WRM_UserConfig');
                    if (!saved) return;
                    const config = JSON.parse(saved);
                    Object.assign(CFG.ui, config.ui || {});
                    Object.assign(CFG.difficulty, config.difficulty || {});
                    Object.assign(CFG.rules, config.rules || {});
                    Object.assign(CFG.physics, config.physics || {});
                } catch (e) {
                    console.warn('Failed to load config:', e);
                }
            }
            function saveConfig() {
                try {
                    const config = {
                        ui: { isInvincible: CFG.ui.isInvincible },
                        difficulty: { ...CFG.difficulty },
                        rules: { ...CFG.rules },
                        physics: { ...CFG.physics }
                    };
                    localStorage.setItem('WRM_UserConfig', JSON.stringify(config));
                } catch (e) {
                    console.warn('Failed to save config:', e);
                }
            }

            // ===== 透视计算 =====
            const VP = { x: W / 2, y: 0 }; // y 将在 drawTrack 中动态计算
            function perspScale(y) {
                const t = (y - VP.y) / (H - VP.y);
                const sStart = CFG.physics.objScaleStart;
                const sEnd = CFG.physics.objScaleEnd;
                return sStart + (sEnd - sStart) * t;
            }
            // v2.9.3: 跑道透视缩放与物体缩放分离
            function trackScale(y) {
                const t = (y - VP.y) / (H - VP.y);
                const sStart = 0.08; // 跑道远端固定缩放
                const sEnd = 1.0;    // 跑道近端固定缩放
                return sStart + (sEnd - sStart) * t;
            }
            function trackX(trackIdx, y) {
                const s = trackScale(y); // 使用独立的跑道缩放
                const baseX = CFG.physics.tracksX[trackIdx] * W;

                const t = (y - VP.y) / (H - VP.y);
                // 将 0.25 改小（例如 0.1），跑道底部会扩张得更开，符合图片比例
                const shrinkFactor = 1.0 - t * 0.1;
                return VP.x + (baseX - VP.x) * s * shrinkFactor;
            }

            // ===== 粒子系统 =====
            function spawnParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    ST.particles.push({
                        x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8 - 3,
                        life: 1, decay: 0.01 + Math.random() * 0.02,
                        size: 2 + Math.random() * 4, color,
                        type: Math.random() > 0.5 ? 'circle' : 'star'
                    });
                }
            }
            function updateParticles() {
                for (let i = ST.particles.length - 1; i >= 0; i--) {
                    const p = ST.particles[i];
                    p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life -= p.decay;
                    if (p.life <= 0) ST.particles.splice(i, 1);
                }
            }
            function drawParticles() {
                ST.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    // v3.0: 纸屑风格粒子，无发光，旋转正方形或圆形
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.life * 5); // 旋转效果
                    if (p.type === 'circle') {
                        ctx.beginPath(); ctx.arc(0, 0, p.size * p.life, 0, Math.PI * 2); ctx.fill();
                    } else {
                        // 碎纸片 (方形)
                        ctx.fillRect(-p.size * p.life, -p.size * p.life, p.size * p.life * 2, p.size * p.life * 2);
                    }
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
            }
            function drawStar(cx, cy, r) {
                // 保留五角星逻辑，用于特效，但也可以简化
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const a = Math.PI * 2 * i / 5 - Math.PI / 2;
                    const x = cx + Math.cos(a) * r, y = cy + Math.sin(a) * r;
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                    const a2 = a + Math.PI / 5;
                    ctx.lineTo(cx + Math.cos(a2) * r * 0.4, cy + Math.sin(a2) * r * 0.4);
                }
                ctx.closePath(); ctx.fill();
            }

            // ===== v3.0: 纸质风格渲染辅助函数 (New Helper Functions) =====
            let paperPattern = null;
            function createPaperPattern() {
                if (paperPattern) return paperPattern;
                const pCanvas = document.createElement('canvas');
                pCanvas.width = 256; pCanvas.height = 256;
                const pCtx = pCanvas.getContext('2d');
                // 基础米色
                pCtx.fillStyle = '#F5F2E9';
                pCtx.fillRect(0, 0, 256, 256);
                // 添加噪点纹理
                for (let i = 0; i < 6000; i++) {
                    pCtx.fillStyle = Math.random() > 0.5 ? 'rgba(0,0,0,0.03)' : 'rgba(255,255,255,0.05)';
                    pCtx.fillRect(Math.random() * 256, Math.random() * 256, 2, 2);
                }
                paperPattern = ctx.createPattern(pCanvas, 'repeat');
                return paperPattern;
            }

            // 绘制粗糙边缘路径 (Wobble Effect)
            function drawRoughPath(ctx, points, closePath = false) {
                if (points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                    const steps = Math.max(1, Math.floor(dist / 20)); // 每20px一个扰动点

                    for (let j = 1; j <= steps; j++) {
                        const t = j / steps;
                        const bx = p1.x + (p2.x - p1.x) * t;
                        const by = p1.y + (p2.y - p1.y) * t;
                        // 随机扰动 (-1.5 到 1.5)
                        const jitX = (Math.random() - 0.5) * 3;
                        const jitY = (Math.random() - 0.5) * 3;
                        ctx.lineTo(bx + jitX, by + jitY);
                    }
                }
                if (closePath) {
                    ctx.closePath();
                }
                // 不在这里 stroke/fill，留给调用者
            }

            // ===== 跑道绘制 (Paper Cutout Style) =====
            function drawTrack() {
                const titleBottom = 20 + 36 + 10;
                const taskUIY = titleBottom + 80;
                VP.y = taskUIY;

                // 1. 全屏背景 (纸张纹理)
                ctx.fillStyle = createPaperPattern();
                ctx.fillRect(0, 0, W, H);

                // 2. 绘制跑道主体 (大剪纸带)
                // 计算左右边缘的关键点
                const trackCheckPointsY = [VP.y, VP.y + (H - VP.y) * 0.25, VP.y + (H - VP.y) * 0.5, VP.y + (H - VP.y) * 0.75, H];
                const leftPoints = [];
                const rightPoints = [];

                trackCheckPointsY.forEach(y => {
                    const lBase = trackX(0, y);
                    const rBase = trackX(2, y);
                    const lw = rBase - lBase; // 两个车道宽 (因为 trackX是中心点)
                    // trackX(0)是左车道中心，trackX(2)是右车道中心。
                    // 跑道总左边缘 = trackX(0) - 0.5 * 单车道宽
                    // 跑道总右边缘 = trackX(2) + 0.5 * 单车道宽
                    // 但是 trackX 是基于 tracksX 配置 [1/6, 1/2, 5/6]
                    // 所以 trackX(1) - trackX(0) = 1/3 W * s
                    // 单车道宽 = trackX(1) - trackX(0)
                    const laneW = trackX(1, y) - trackX(0, y);

                    // 稍微加宽一点边缘作为跑道纸带边界
                    leftPoints.push({ x: trackX(0, y) - laneW * 0.6, y: y });
                    rightPoints.push({ x: trackX(2, y) + laneW * 0.6, y: y });
                });

                // 构建完整的多边形路径
                const polyPoints = [...leftPoints, ...rightPoints.reverse()];

                ctx.save();
                // 白色毛边阴影 (Hard Shadow)
                ctx.translate(2, 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                drawRoughPath(ctx, polyPoints, true);
                ctx.fill();
                ctx.translate(-2, -2);

                // 跑道本体 (深一点的米色或浅灰，模拟重叠纸张)
                ctx.fillStyle = '#EBE7DD'; // 略深于背景
                drawRoughPath(ctx, polyPoints, true);
                ctx.fill();

                // 边缘描边 (铅笔痕迹)
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();

                // 3. 绘制车道分隔线 (虚线剪裁效果)
                ctx.save();
                ctx.strokeStyle = 'rgba(0,0,0,0.15)'; // 淡淡的压痕色
                ctx.lineWidth = 2;
                ctx.setLineDash([15, 15]); // 宽虚线

                // 线1 (跑道 0|1 之间)
                // 线2 (跑道 1|2 之间)
                // trackX(0) 是第一车道中心。分隔线应在 trackX(0) + laneW/2
                // 其实 trackX(0)和trackX(1)的中点就是分隔线
                const divLines = [0, 1];
                divLines.forEach(idx => {
                    const points = [];
                    trackCheckPointsY.forEach(y => {
                        const x = (trackX(idx, y) + trackX(idx + 1, y)) / 2;
                        points.push({ x, y });
                    });

                    // 用 rough path 绘制虚线有点奇怪，直接画带抖动的虚线
                    // 这里简化，直接画直虚线，配合手绘风背景即可
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    points.forEach((p, i) => { if (i > 0) ctx.lineTo(p.x, p.y); });
                    ctx.stroke();
                });
                ctx.restore();

                // 4. 起跑线/装饰横线 (贴纸条)
                // 移动的跑道装饰线
                ST.roadLines.forEach(rl => {
                    const s = trackScale(rl.y);
                    const h = s * 20;

                    // 绘制在两个分隔线位置的小横贴纸
                    for (let i = 0; i < 2; i++) {
                        const xLeft = trackX(i, rl.y);
                        const xRight = trackX(i + 1, rl.y);
                        const cx = (xLeft + xRight) / 2;
                        const w = 30 * s;

                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(cx - w / 2, rl.y, w, h);
                    }
                });
            }
            function updateRoadLines() {
                const diff = getDifficulty();
                // 添加新线
                if (ST.frameCount % 15 === 0) {
                    ST.roadLines.push({ y: VP.y });
                }
                // v2.8: 移动（受跑动速度影响）
                for (let i = ST.roadLines.length - 1; i >= 0; i--) {
                    ST.roadLines[i].y += diff.speed * 1.5 * ST.runSpeedMultiplier;
                    if (ST.roadLines[i].y > H) ST.roadLines.splice(i, 1);
                }
            }

            // ===== 跳跃轨迹绘制 =====
            // ===== 跳跃轨迹绘制 (缝纫线风格) =====
            function drawJumpTrajectory() {
                if (!ST.isJumping) return;

                ctx.save();
                ctx.strokeStyle = '#555'; // 深色缝衣线
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // 明显的虚线

                ctx.beginPath();
                const px = trackX(ST.trackIndex, H * CFG.physics.playerY);
                const py = H * CFG.physics.playerY - ST.playerJump;

                // 模拟抛物线轨迹
                let simY = ST.playerJump;
                let simVy = ST.jumpVy;
                const dt = 1 / 60;

                ctx.moveTo(px, py);
                let landingY = py;
                for (let i = 0; i < 60 && simY >= 0; i++) {
                    simY += simVy * dt;
                    simVy -= CFG.physics.gravity * dt;
                    const nextY = H * CFG.physics.playerY - simY;
                    ctx.lineTo(px, nextY);
                    landingY = nextY;
                }

                ctx.stroke();
                ctx.setLineDash([]);

                // 落点标记 (小叉号 X)
                const jumpDuration = (2 * Math.abs(ST.jumpVy)) / CFG.physics.gravity;
                const diff = getDifficulty();
                const fallDistance = diff.speed * jumpDuration;
                const targetY = Math.min(H, landingY + fallDistance);

                ctx.strokeStyle = '#d63031';
                ctx.lineWidth = 3;
                const xSz = 8;
                ctx.beginPath();
                ctx.moveTo(px - xSz, targetY - xSz);
                ctx.lineTo(px + xSz, targetY + xSz);
                ctx.moveTo(px + xSz, targetY - xSz);
                ctx.lineTo(px - xSz, targetY + xSz);
                ctx.stroke();

                ctx.restore();
            }

            // ===== v2.6: 角色绘制（正面视角，面朝任务区奔跑）=====
            // ===== v3.0: 纸偶角色绘制 (Paper Puppet) =====
            function drawPlayer() {
                const ti = ST.trackIndex;
                const py = H * CFG.physics.playerY;
                const px = trackX(ti, py);
                const baseScale = CFG.physics.playerScale;
                const sX = baseScale * (2 - ST.landingScale);
                const sY = baseScale * ST.landingScale;

                const jy = ST.playerJump;
                const t = ST.playerAnim;
                const tc = '#F7B731'; // 身体主色 (暖黄)
                const pantsColor = '#2D3436'; // 裤子深灰
                const skinColor = '#FFDAB9'; // 皮肤粉色

                const animPhase = ST.isRunning ? ST.runAnimPhase : t;
                const runCycle = Math.sin(animPhase);
                const runCycle2 = Math.cos(animPhase);

                // 身体颠簸
                let bobbing = 0;
                if (ST.isRunning && !ST.isJumping) {
                    bobbing = Math.abs(Math.sin(animPhase * 2)) * 6 * sY;
                }
                const by = py - jy - bobbing;

                // 影子 (硬边深色椭圆)
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.2)'; // 硬投影
                const shadowScale = Math.max(0.2, 1 - jy / 200);
                // 投影稍微偏移模拟厚度
                ctx.beginPath();
                ctx.ellipse(px + 4, py + 8 * sY + 2, 18 * sX * shadowScale, 5 * sY * shadowScale, 0, 0, Math.PI * 2);
                ctx.fill();

                // 恢复落地形变
                if (ST.landingScale < 1.0) {
                    ST.landingScale += 0.05;
                    if (ST.landingScale > 1.0) ST.landingScale = 1.0;
                }

                const headR = 10 * sY;
                const bodyW = 16 * sX, bodyH = 22 * sY;
                const limbW = 5 * sX;

                // 绘制纸偶部件函数
                function drawLimb(x1, y1, x2, y2, color, w) {
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    // 模拟剪纸边缘的粗线条
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    // 铆钉
                    ctx.fillStyle = '#b2bec3';
                    ctx.beginPath(); ctx.arc(x1, y1, w * 0.3, 0, Math.PI * 2); ctx.fill();
                }

                // 增强跑动幅度
                const swingMultiplier = ST.isRunning ? 2.5 : 1.0;
                let legSwingY = runCycle * 12 * sY * swingMultiplier;
                let legSwingX = Math.abs(runCycle) * 3 * sX;

                if (ST.isJumping) {
                    legSwingY = 8 * sY;
                    legSwingX = 2 * sX;
                }

                // 左腿
                drawLimb(px - 4 * sX, by - 4 * sY, px - 4 * sX - legSwingX * 0.3, by + 10 * sY - legSwingY, pantsColor, limbW); // 大腿
                drawLimb(px - 4 * sX - legSwingX * 0.3, by + 10 * sY - legSwingY, px - 4 * sX, by + 18 * sY - legSwingY * 0.5, pantsColor, limbW); // 小腿

                // 右腿
                drawLimb(px + 4 * sX, by - 4 * sY, px + 4 * sX + legSwingX * 0.3, by + 10 * sY + legSwingY, pantsColor, limbW);
                drawLimb(px + 4 * sX + legSwingX * 0.3, by + 10 * sY + legSwingY, px + 4 * sX, by + 18 * sY + legSwingY * 0.5, pantsColor, limbW);

                // 身体 (圆角矩形纸片)
                ctx.fillStyle = '#0984e3'; // 蓝色衣服
                // 绘制带旋转的身体
                ctx.beginPath();
                const bodyRot = runCycle * 0.1;
                roundRect(px - bodyW / 2, by - bodyH - headR * 0.5, bodyW, bodyH, 4 * sX);
                // 衣服领口装饰
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(px, by - bodyH - headR * 0.5, 4 * sX, 0, Math.PI); ctx.fill();

                // 头部 (肤色纸片)
                ctx.fillStyle = skinColor;
                ctx.beginPath(); ctx.arc(px, by - bodyH - headR * 1.2, headR, 0, Math.PI * 2); ctx.fill();
                // 脸颊红晕
                ctx.fillStyle = '#fab1a0';
                ctx.beginPath(); ctx.arc(px - 4 * sX, by - bodyH - headR * 1.2 + 2 * sY, 2 * sX, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(px + 4 * sX, by - bodyH - headR * 1.2 + 2 * sY, 2 * sX, 0, Math.PI * 2); ctx.fill();
                // 眼睛
                ctx.fillStyle = '#333';
                ctx.beginPath(); ctx.arc(px - 3 * sX, by - bodyH - headR * 1.4, 1.5 * sX, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(px + 3 * sX, by - bodyH - headR * 1.4, 1.5 * sX, 0, Math.PI * 2); ctx.fill();

                // 手臂
                let armSwingY = -runCycle * 10 * sY * swingMultiplier;
                if (ST.isJumping) armSwingY = -12 * sY;

                // 左臂
                drawLimb(px - bodyW / 2, by - bodyH + 2 * sY, px - bodyW / 2 - 6 * sX, by - bodyH / 2 - armSwingY * 0.4, skinColor, limbW * 0.9);
                drawLimb(px - bodyW / 2 - 6 * sX, by - bodyH / 2 - armSwingY * 0.4, px - bodyW / 2 - 4 * sX, by - bodyH / 2 + 8 * sY - armSwingY * 0.2, skinColor, limbW * 0.9);

                // 右臂
                drawLimb(px + bodyW / 2, by - bodyH + 2 * sY, px + bodyW / 2 + 6 * sX, by - bodyH / 2 + armSwingY * 0.4, skinColor, limbW * 0.9);
                drawLimb(px + bodyW / 2 + 6 * sX, by - bodyH / 2 + armSwingY * 0.4, px + bodyW / 2 + 4 * sX, by - bodyH / 2 + 8 * sY + armSwingY * 0.2, skinColor, limbW * 0.9);

                // 昵称标签 (纸条风格)
                const hue = (ST.frameCount * 2) % 360;
                ctx.font = `bold ${14 * sY}px "Microsoft YaHei"`; ctx.textAlign = 'center';
                // 白色底标签
                const textW = ctx.measureText(CFG.metadata.playerName).width;
                ctx.fillStyle = '#fff';
                ctx.fillRect(px - textW / 2 - 4, by - bodyH - headR * 3.0 - 14, textW + 8, 18);
                ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.strokeRect(px - textW / 2 - 4, by - bodyH - headR * 3.0 - 14, textW + 8, 18);

                ctx.fillStyle = '#333';
                ctx.fillText(CFG.metadata.playerName, px, by - bodyH - headR * 2.8);

                ctx.restore();
            }

            // 圆角矩形辅助
            function roundRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath(); ctx.fill();
            }

            // HEX转RGB
            function hexToRGB(hex) {
                const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            }

            // ===== 圆形任务UI (中心点与消失点重合) =====
            // 绘制游戏标题
            // 构建游戏标题 (墨水风格)
            function drawGameTitle() {
                ctx.save();
                ctx.font = 'bold 36px "Microsoft YaHei"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                // 黑色水墨阴影
                ctx.fillStyle = '#333';
                ctx.fillText('字跑大师', W / 2, 22);
                // 主色
                ctx.fillStyle = '#2d3436';
                ctx.fillText('字跑大师', W / 2, 20);

                ctx.restore();
            }

            function drawTaskRing() {
                const titleBottom = 20 + 36 + 10;
                const cx = W / 2;
                const cy = titleBottom + 80;
                const ringR = W / 6;

                ctx.save();

                // 1. 贴纸底色 (圆形白纸)
                ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 5; ctx.shadowOffsetY = 2;
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(cx, cy, ringR, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;

                // 2. 边缘缝线
                ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.arc(cx, cy, ringR - 4, 0, Math.PI * 2); ctx.stroke();
                ctx.setLineDash([]);

                // 3. 进度印章
                const segmentCount = CFG.rules.winCorrectTotal;
                const segmentAngle = (Math.PI * 2) / segmentCount;
                const startAngle = -Math.PI / 2;

                for (let i = 0; i < segmentCount; i++) {
                    const angle = startAngle + i * segmentAngle + segmentAngle / 2;
                    const r = ringR - 10;
                    const px = cx + Math.cos(angle) * r;
                    const py = cy + Math.sin(angle) * r;

                    if (i < ST.correctTotal) {
                        // 已完成：红色印章点
                        ctx.fillStyle = '#d63031';
                        // 随机微小偏移模拟手工盖章
                        const rx = px + (Math.sin(i * 132) * 2);
                        const ry = py + (Math.cos(i * 132) * 2);
                        ctx.beginPath(); ctx.arc(rx, ry, 5, 0, Math.PI * 2); ctx.fill();
                    } else {
                        // 未完成：灰色圆圈
                        ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
                        ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI * 2); ctx.stroke();
                    }
                }

                // 中心拼音 (墨水字)
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillStyle = '#2d3436';
                ctx.font = `bold ${Math.floor(ringR * 0.45)}px "Microsoft YaHei"`;
                ctx.fillText(ST.currentPinyin || '--', cx, cy - 4);

                // 进度数字
                ctx.font = `bold ${Math.floor(ringR * 0.22)}px "Microsoft YaHei"`;
                ctx.fillStyle = '#636e72';
                ctx.fillText(`${ST.completedWordCount + 1}/${allData.length}`, cx, cy + ringR * 0.45);

                ctx.restore();
            }

            // ===== 物体系统 =====
            function spawnObject() {
                if (ST.paused || ST.gameOver || !ST.running) return;
                const diff = getDifficulty();
                let r = Math.random();
                let type, word = '', pinyin = '';

                // v2.6: 正确项生成保障 — 确保关卡内能出现足够的正确项
                const remaining = CFG.rules.levelTime - ST.levelTime;
                const needed = CFG.rules.winCorrectTotal - ST.correctTotal;
                if (needed > 0 && remaining > 0) {
                    const avgInterval = (CFG.difficulty.intervalStart + CFG.difficulty.intervalEnd) / 2;
                    const estimatedSpawns = remaining * 1000 / avgInterval;
                    const pCorrect = diff.pCorrect || (1 - diff.pObstacle - diff.pWrong);
                    if (estimatedSpawns * pCorrect < needed * 1.8) {
                        r = 1.0; // 强制落入 correct 区间
                    }
                }

                // 确定物体类型
                const pObs = diff.pObstacle;
                const pWrong = diff.pWrong;
                // pCorrect is the rest

                if (r < pObs) {
                    type = 'obstacle';
                } else if (r < pObs + pWrong) {
                    type = 'wrong';
                    // v2.8: 严格排除同音字 — 干扰项不能是任何与当前拼音相同的汉字
                    const correctWords = allData.filter(d => d.pinyin === ST.currentPinyin).map(d => d.word);
                    const pool = allData.filter(d => d.pinyin !== ST.currentPinyin && !correctWords.includes(d.word));
                    if (pool.length > 0) { const item = pool[Math.floor(Math.random() * pool.length)]; word = item.word; pinyin = item.pinyin; }
                    else { type = 'obstacle'; } // fallback
                } else {
                    type = 'correct';
                    // v2.8: 只生成本关的唯一正确汉字
                    if (ST.currentCorrectWord) {
                        word = ST.currentCorrectWord;
                        pinyin = ST.currentPinyin;
                    } else {
                        type = 'obstacle'; // fallback
                    }
                }

                // 选择跑道（不在同一跑道放相同干扰项）
                let track = Math.floor(Math.random() * 3);
                const existingOnTrack = ST.objects.filter(o => o.track === track && o.y < VP.y + 100);
                if (existingOnTrack.length > 0) track = (track + 1) % 3;

                ST.objects.push({
                    type, track, y: VP.y, word, pinyin,
                    alive: true, scale: 0.08
                });
            }

            function updateObjects() {
                const diff = getDifficulty();
                const py = H * CFG.physics.playerY;

                for (let i = ST.objects.length - 1; i >= 0; i--) {
                    const o = ST.objects[i];
                    // v2.8: 跑动时速度加倍
                    const speed = diff.speed * ST.runSpeedMultiplier;
                    o.y += speed;
                    o.scale = perspScale(o.y);

                    // 碰撞检测
                    if (o.alive && o.y > py - 40 && o.y < py + 20) {
                        const ox = trackX(o.track, o.y);
                        const px = trackX(ST.trackIndex, py);
                        const dist = Math.abs(ox - px);

                        if (dist < 30 * o.scale) {
                            // 玩家在跳跃中 → 跳过
                            if (ST.isJumping && ST.playerJump > 30) {
                                if (o.type === 'obstacle') {
                                    ST.score += CFG.scoring.dodgeObstacle;
                                }
                                // 跳过不触发碰撞
                            } else {
                                handleCollision(o);
                            }
                            o.alive = false;
                        }
                    }

                    // 移出屏幕
                    if (o.y > H + 50) {
                        ST.objects.splice(i, 1);
                    }
                }
            }

            function drawObjects() {
                ST.objects.forEach(o => {
                    if (!o.alive) return;
                    const x = trackX(o.track, o.y);
                    let s = o.scale;

                    if (o.type === 'obstacle') s = s * CFG.physics.obstacleScale;

                    ctx.save();

                    if (o.type === 'obstacle') {
                        // v3.0: 施工路障 (剪纸风)
                        // 底层 (白色硬纸板)
                        const sz = 22 * s;
                        const barW = sz * 2.2;
                        const barH = sz * 1.4;
                        const postW = 5 * s;

                        ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowOffsetY = 3; ctx.shadowBlur = 4;

                        // 绘制整体形状作为底层
                        ctx.fillStyle = '#fff';
                        // 左右桩 + 横杠
                        ctx.fillRect(x - barW / 2 - 2, o.y - barH / 2 - 2, postW + 4, barH + 4); // 左
                        ctx.fillRect(x + barW / 2 - postW - 2, o.y - barH / 2 - 2, postW + 4, barH + 4); // 右
                        ctx.fillRect(x - barW / 2, o.y - barH * 0.15 - 2 * s, barW, barH * 0.3 + 4 * s); // 横

                        ctx.shadowColor = 'transparent'; //清除阴影，绘制顶层

                        // 顶层立柱
                        ctx.fillStyle = '#e67e22'; // 橙色纸
                        ctx.fillRect(x - barW / 2, o.y - barH / 2, postW, barH);
                        ctx.fillRect(x + barW / 2 - postW, o.y - barH / 2, postW, barH);

                        // 横杠 (红白条)
                        for (let i = 0; i < 5; i++) {
                            ctx.fillStyle = i % 2 === 0 ? '#ff7675' : '#fff';
                            const segW = (barW - postW * 2) / 5;
                            ctx.fillRect(x - barW / 2 + postW + i * segW, o.y - barH * 0.15, segW, barH * 0.3);
                        }

                        // 警告牌 (!)
                        const triSz = sz * 0.6;
                        const triY = o.y - barH * 0.5;
                        ctx.fillStyle = '#ffeaa7';
                        ctx.beginPath();
                        ctx.moveTo(x, triY - triSz);
                        ctx.lineTo(x - triSz, triY + triSz * 0.5);
                        ctx.lineTo(x + triSz, triY + triSz * 0.5);
                        ctx.fill();

                        ctx.fillStyle = '#333';
                        ctx.font = `bold ${10 * s}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText('!', x, triY + triSz * 0.2);

                    } else {
                        // 字球 (双层剪纸)
                        const r = 24 * s;

                        // 1. 底层白色轮廓 (带阴影)
                        ctx.save();
                        ctx.translate(x, o.y);
                        ctx.shadowColor = 'rgba(0,0,0,0.2)';
                        ctx.shadowOffsetY = 3;
                        ctx.shadowBlur = 2;

                        ctx.fillStyle = '#fff';
                        // 稍微大一圈的不规则圆
                        ctx.beginPath();
                        ctx.arc(0, 0, r + 2 * s, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        // 2. 顶层色纸
                        ctx.beginPath();
                        ctx.arc(x, o.y, r, 0, Math.PI * 2);
                        // 根据类型决定颜色
                        if (o.type === 'correct') {
                            ctx.fillStyle = '#55efc4'; // 绿色纸
                        } else {
                            // wrong
                            ctx.fillStyle = '#fab1a0'; // 红色纸
                            // 错误项加上皱褶纹理
                            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                            ctx.lineWidth = 1;
                            ctx.moveTo(x - r * 0.5, o.y - r * 0.2); ctx.lineTo(x + r * 0.5, o.y + r * 0.4); ctx.stroke();
                        }
                        ctx.fill();

                        // 3. 汉字 (墨水风)
                        ctx.fillStyle = '#2d3436';
                        ctx.font = `bold ${22 * s}px "Microsoft YaHei"`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(o.word, x, o.y);
                    }
                    ctx.restore();
                });
            }

            // ===== 碰撞处理 =====
            function handleCollision(o) {
                // v2.8.6: 通关动画期间无敌
                if (ST.isCompletingLevel && o.type !== 'correct') return;
                if (CFG.ui.isInvincible && o.type !== 'correct') return;

                if (o.type === 'obstacle') {
                    ST.lives -= CFG.rules.obstacleDamage;
                    SFX.hit();
                    ST.combo = 0; ST.wrongStreak = 0;
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff3c3c', 15);
                } else if (o.type === 'wrong') {
                    ST.lives -= CFG.rules.wrongDamage;
                    SFX.wrong();
                    ST.combo = 0;
                    ST.wrongStreak++;
                    ST.correctStreak = 0;
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff6b6b', 10);
                } else if (o.type === 'correct') {
                    ST.combo++;
                    if (ST.combo > ST.maxCombo) ST.maxCombo = ST.combo;
                    const multiplier = Math.min(ST.combo, CFG.scoring.comboMax);
                    ST.score += CFG.scoring.correctBase * multiplier;
                    ST.correctTotal++;
                    ST.correctStreak++;
                    ST.wrongStreak = 0;
                    SFX.correct({ pinyin: ST.currentPinyin, word: o.word }); // v2.8: 传入word用于播放汉字读音
                    spawnParticles(trackX(o.track, o.y), o.y, '#00ffcc', 25);
                    spawnParticles(trackX(o.track, o.y), o.y, '#ffd700', 15);
                    spawnParticles(trackX(o.track, o.y), o.y, '#ff69b4', 10);
                }

                // v2.8.6: 每次连击重置显示时间
                if (ST.combo >= 2) ST.comboDisplayTimer = 0.8; // 0.8秒后消失

                updateHUD();
                checkLevelState();
            }

            // ===== 关卡检查 =====
            function checkLevelState() {
                if (ST.lives <= 0) {
                    endGame(); return;
                }
                // 连击4个错误 → 失败
                if (ST.wrongStreak >= CFG.rules.failWrongStreak) {
                    endGame(); return;
                }
                // 累计9个正确 或 连续4个正确 → 过关
                // v2.8.6: 延迟通关逻辑
                const isWin = ST.correctTotal >= CFG.rules.winCorrectTotal || ST.correctStreak >= CFG.rules.winCorrectStreak;

                if (isWin && !ST.isCompletingLevel) {
                    // 开始通关流程：光环动画 -> 延迟 -> 弹窗
                    ST.isCompletingLevel = true;
                    ST.ringCompleteAnim = 1.0; // 触发外环闪烁动画
                    SFX.levelUp(); // 播放音效

                    // 1.5秒后显示结算界面
                    setTimeout(() => {
                        clearLevel();
                    }, 1500);
                }
            }

            function clearLevel() {
                ST.paused = true;
                ST.totalLevelsCleared++;
                ST.streakLevels++;
                // ST.ringCompleteAnim = 1.0; // 移至 checkLevelState 提前触发

                // 积分奖励
                const remaining = CFG.rules.levelTime - ST.levelTime;
                ST.score += CFG.scoring.levelClear + Math.floor(remaining) * CFG.scoring.timeBonus;
                ST.score += ST.streakLevels * CFG.scoring.streakBonus;
                SFX.levelUp();

                // v2.8: 累加已完成的字数
                ST.completedWordCount++;

                // v2.8.2: 修正通关简报显示
                const lcInfo = document.getElementById('lc-info');
                const justPassedLevel = ST.levelIndex + 1; // 刚通过的是第X关

                // 通关标题
                document.querySelector('#level-clear h2').textContent = `第${justPassedLevel}关 通过！`;

                // v2.8: 任务简报只显示本关的正确汉字
                lcInfo.innerHTML = `任务：${ST.currentPinyin} → ${ST.currentCorrectWord}<br>正确：${ST.correctTotal}个 | 连击：${ST.maxCombo}<br>得分：${ST.score}分<br>等级：${getLevel(ST.score).rank}`;

                document.getElementById('level-clear').style.display = 'flex';
            }

            function nextLevel() {
                document.getElementById('level-clear').style.display = 'none';
                ST.levelIndex++;
                if (ST.levelIndex >= pinyinList.length) {
                    // 所有关卡完成
                    endGame(true); return;
                }
                startLevel();
            }

            function startLevel() {
                ST.levelTime = 0; ST.correctTotal = 0; ST.correctStreak = 0; ST.wrongStreak = 0; ST.combo = 0; ST.maxCombo = 0;
                ST.comboDisplayTimer = 0; // v2.8.6: 连击显示计时器
                ST.isCompletingLevel = false; // v2.8.6: 重置通关状态
                ST.objects = []; ST.particles = [];
                ST.appearedCorrectWords.clear(); // v2.5: 重置同音字记录
                ST.currentPinyin = pinyinList[ST.levelIndex];
                const matches = allData.filter(d => d.pinyin === ST.currentPinyin);
                // v2.8: 为本关选择唯一的正确汉字
                if (matches.length > 0) {
                    const selectedItem = matches[Math.floor(Math.random() * matches.length)];
                    ST.currentCorrectWord = selectedItem.word;
                    ST.currentWord = selectedItem.word; // 只显示本关的正确汉字
                } else {
                    ST.currentCorrectWord = '';
                    ST.currentWord = ST.currentPinyin;
                }
                ST.paused = false;
                ST.levelTimer = 0;
                updateHUD();
                // v2.8: 任务提示音 - 播放汉字读音而非拼音
                setTimeout(() => speakWord(ST.currentCorrectWord || ST.currentPinyin), 300);
            }

            function endGame(allClear) {
                ST.gameOver = true; ST.running = false;
                if (!allClear) ST.failedLevelIndex = ST.levelIndex; // v2.8: 记录失败的关卡索引
                stopBGM();
                if (!allClear) SFX.gameOver(); else SFX.levelUp();
                const stats = document.getElementById('go-stats');
                const title = document.querySelector('#game-over h2');
                title.textContent = allClear ? '🎉 全部通关！' : '游戏结束';
                title.style.color = allClear ? '#00ffcc' : '#ff6b6b';
                // v2.8.1: 修复游戏结束统计信息，显示正确的进度
                const currentProgress = `${ST.completedWordCount}/${allData.length}`; // 当前已完成的字数
                const currentLevel = `第${ST.levelIndex + 1}关`; // 当前关卡
                stats.innerHTML = `当前进度：${currentProgress}<br>当前小关：${currentLevel}<br>总得分：${ST.score}<br>最高连击：${ST.maxCombo}<br>等级：${getLevel(ST.score).rank}`;
                document.getElementById('game-over').style.display = 'flex';
            }

            function restartGame() {
                document.getElementById('game-over').style.display = 'none';
                ST.lives = CFG.rules.initLives; ST.score = 0; ST.combo = 0; ST.maxCombo = 0;
                // v2.8: 从失败的关卡重新开始，保持进度
                if (ST.failedLevelIndex >= 0) {
                    ST.levelIndex = ST.failedLevelIndex;
                    // completedWordCount 保持不变，显示当前进度
                } else {
                    ST.levelIndex = 0;
                    ST.completedWordCount = 0;
                }
                ST.totalLevelsCleared = 0; ST.streakLevels = 0;
                ST.objects = []; ST.particles = []; ST.roadLines = [];
                ST.appearedCorrectWords.clear();
                ST.lastTime = 0; // v2.6: 重置时间戳，修复 dt 异常
                ST.gameOver = false; ST.running = true; ST.paused = false;
                if (ST.failedLevelIndex < 0) shuffleArray(pinyinList); // 只在全新开始时打乱
                startLevel();
                startBGM();
            }

            // ===== HUD 更新 =====
            function updateHUD() {
                // 分数 & 生命
                // 生命值 (支持半心)
                let hearts = '';
                const full = Math.floor(ST.lives);
                const half = ST.lives % 1 >= 0.5 ? 1 : 0;
                const empty = Math.max(0, CFG.rules.initLives - full - half);
                for (let i = 0; i < full; i++) hearts += '❤️';
                if (half) hearts += '💔';
                for (let i = 0; i < empty; i++) hearts += '🖤';
                document.getElementById('hud-hearts').textContent = hearts;

                // 时间
                const remaining = Math.max(0, Math.ceil(CFG.rules.levelTime - ST.levelTime));
                document.getElementById('hud-timer').textContent = remaining + 's';
                document.getElementById('hud-timer').style.color = remaining <= 10 ? '#ff3c3c' : '#ff6b6b';

                // 任务
                document.getElementById('hud-task').textContent = `任务：${ST.currentPinyin}`;

                // 分数
                document.getElementById('hud-score').textContent = ST.score + '分';

                // 等级
                const lv = getLevel(ST.score);
                const lvIdx = CFG.levels.indexOf(lv) + 1;
                document.getElementById('hud-level').textContent = `Lv.${lvIdx} ${lv.rank}`;

                // v2.8.6: 连击提示优化（带动画）
                const comboEl = document.getElementById('hud-combo');
                if (ST.combo >= 2 && ST.comboDisplayTimer > 0) {
                    comboEl.textContent = `🔥 ${ST.combo}连击！`;
                    comboEl.classList.remove('fade-out');
                    comboEl.style.opacity = '1';
                } else {
                    comboEl.classList.add('fade-out');
                    // opacity由CSS处理
                }
            }

            // ===== 物体生成计时器 =====
            let spawnTimer = 0;
            function updateSpawner(dt) {
                const diff = getDifficulty();
                spawnTimer += dt * 1000;
                if (spawnTimer >= diff.interval) {
                    spawnObject();
                    spawnTimer = 0;
                }
            }

            // ===== 主循环 =====
            function gameLoop(timestamp) {
                requestAnimationFrame(gameLoop);
                if (!ST.running) return;
                if (ST.lastTime === 0) ST.lastTime = timestamp;
                const dt = Math.min((timestamp - ST.lastTime) / 1000, 0.05);
                ST.lastTime = timestamp; ST.frameCount++;
                if (ST.paused) return;

                // 关卡计时
                // 关卡计时
                // v2.8.6: 通关动画期间停止计时
                if (!ST.isCompletingLevel) {
                    ST.levelTime += dt;
                    if (ST.levelTime >= CFG.rules.levelTime) {
                        endGame(); return;
                    }
                }

                // v2.8.6: 更新连击计时器
                if (ST.comboDisplayTimer > 0) {
                    ST.comboDisplayTimer -= dt;
                    if (ST.comboDisplayTimer <= 0) updateHUD(); // 触发消失动画
                }

                // v2.8.3: 检测长按并更新跑动状态
                updateRunningState();

                // v2.8: 角色动画（跑动比走动快）
                const animSpeed = ST.isRunning ? 0.2 : 0.12;
                ST.playerAnim += animSpeed;

                // 跳跃物理
                // 跳跃物理 update
                if (ST.isJumping) {
                    ST.playerJump += ST.jumpVy * dt;
                    ST.jumpVy -= CFG.physics.gravity * dt;

                    // 落地检测
                    if (ST.playerJump <= 0) {
                        ST.playerJump = 0;
                        ST.isJumping = false;
                        // 落地特效
                        SFX.hit(); // 或者单独的 land 音效
                        spawnParticles(trackX(ST.trackIndex, H * CFG.physics.playerY), H * CFG.physics.playerY, '#fff', 5);
                        ST.landingScale = 0.6; // 触发挤压动画
                    }
                }

                // 更新
                updateRoadLines();
                updateSpawner(dt);
                updateObjects();
                updateParticles();
                updateHUD();

                // 绘制
                ctx.clearRect(0, 0, W, H);
                drawTrack();
                drawGameTitle();
                drawTaskRing();
                drawJumpTrajectory();
                drawObjects();
                drawPlayer();
                drawParticles();
            }

            // v2.8.3: 跳跃 (物理驱动，支持原地跳和跑动跳)
            function jumpPlayer(isRunJump = false) {
                if (ST.isJumping || !ST.running || ST.paused) return;
                ST.isJumping = true;
                // 跑动中跳跃力度更大
                ST.jumpVy = isRunJump ? CFG.physics.jumpForce * 1.3 : CFG.physics.jumpForce;
                SFX.jump();
            }

            // ===== 车道切换 =====
            function movePlayer(dir) {
                if (!ST.running || ST.paused) return;
                ST.trackIndex = Math.max(0, Math.min(2, ST.trackIndex + dir));
            }

            // ===== 暂停 =====
            function togglePause() {
                if (!ST.running || ST.gameOver) return;
                ST.paused = !ST.paused;
                document.getElementById('hud-task').textContent = ST.paused ? '⏸ 已暂停' : `寻找拼音：${ST.currentPinyin}`;
            }

            // v2.8.3: 按键状态跟踪（用于单击/长按/双击检测）
            let lastUpKeyTime = 0;
            let upKeyPressed = false;
            let upKeyPressTime = 0;
            const LONG_PRESS_THRESHOLD = 200; // 长按阈值（毫秒）
            const DOUBLE_CLICK_THRESHOLD = 300; // 双击阈值（毫秒）

            // ===== 键盘输入 =====
            document.addEventListener('keydown', e => {
                if (e.code === 'ArrowUp' && !upKeyPressed) {
                    upKeyPressed = true;
                    upKeyPressTime = Date.now();
                    e.preventDefault();
                } else if (e.code === 'ArrowLeft') {
                    movePlayer(-1); e.preventDefault();
                } else if (e.code === 'ArrowRight') {
                    movePlayer(1); e.preventDefault();
                } else if (e.code === 'Space') {
                    togglePause(); e.preventDefault();
                }
            });

            document.addEventListener('keyup', e => {
                if (e.code === 'ArrowUp' && upKeyPressed) {
                    const now = Date.now();
                    const pressDuration = now - upKeyPressTime;
                    upKeyPressed = false;

                    // 判断是否为长按（跑动）
                    if (pressDuration >= LONG_PRESS_THRESHOLD) {
                        // 长按结束，停止跑动
                        ST.isRunning = false;
                        ST.runSpeedMultiplier = 1.0;
                    } else {
                        // 快速单击
                        // 检查是否为双击（在跑动状态下的双击跳跃）
                        if (ST.isRunning && now - lastUpKeyTime < DOUBLE_CLICK_THRESHOLD) {
                            // 跑动中双击 = 跑动跳跃
                            jumpPlayer(true);
                            lastUpKeyTime = 0;
                        } else {
                            // 单击 = 原地跳跃
                            jumpPlayer(false);
                            lastUpKeyTime = now;
                        }
                    }
                }
            });

            // v2.8.3: 检测长按并触发跑动
            function updateRunningState() {
                if (upKeyPressed && !ST.isRunning) {
                    const pressDuration = Date.now() - upKeyPressTime;
                    if (pressDuration >= LONG_PRESS_THRESHOLD) {
                        ST.isRunning = true;
                        ST.runSpeedMultiplier = 2.0;
                    }
                }
                // 更新跑动动画
                if (ST.isRunning && !ST.paused) {
                    ST.runAnimPhase = (ST.runAnimPhase + 0.2) % (Math.PI * 2);
                }
            }

            // ===== 触摸手势 =====
            let touchStartX = 0, touchStartY = 0, touchStartTime = 0, lastTapTime = 0, lastUpTapTime = 0;
            document.addEventListener('touchstart', e => {
                const t = e.touches[0]; touchStartX = t.clientX; touchStartY = t.clientY; touchStartTime = Date.now();
                e.preventDefault();
            }, { passive: false });
            document.addEventListener('touchend', e => {
                const t = e.changedTouches[0];
                const dx = t.clientX - touchStartX, dy = t.clientY - touchStartY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const elapsed = Date.now() - touchStartTime;

                if (dist < 20 && elapsed < 300) {
                    // 点击 → 检查双击
                    const now = Date.now();
                    if (now - lastTapTime < 350) { togglePause(); lastTapTime = 0; }
                    else lastTapTime = now;
                } else if (dist > 30) {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        dx < 0 ? movePlayer(-1) : movePlayer(1);
                    } else if (dy < -30) {
                        // v2.8: 向上滑动 - 检测双击跳跃 vs 单击跑动
                        const now = Date.now();
                        if (now - lastUpTapTime < 300) {
                            jumpPlayer();
                            lastUpTapTime = 0;
                        } else {
                            ST.isRunning = true;
                            ST.runSpeedMultiplier = 2.0;
                            lastUpTapTime = now;
                            // 0.5秒后自动恢复走动
                            setTimeout(() => {
                                ST.isRunning = false;
                                ST.runSpeedMultiplier = 1.0;
                            }, 500);
                        }
                    }
                }
                e.preventDefault();
            }, { passive: false });


            // ===== 启动 =====
            // 页面加载时加载保存的配置
            loadConfig();
            // v2.9.1: 同步 ST.lives（loadConfig 在 ST 初始化之后执行，需手动同步）
            ST.lives = CFG.rules.initLives;

            document.getElementById('start-btn').onclick = () => {
                const ss = document.getElementById('start-screen');
                ss.style.opacity = '0';
                setTimeout(() => ss.remove(), 600);
                ensureAudio();
                // 预热 TTS
                const v = new SpeechSynthesisUtterance(''); v.volume = 0; window.speechSynthesis.speak(v);
                startBGM();
                ST.running = true;
                startLevel();
                requestAnimationFrame(gameLoop);
            };

            document.getElementById('go-restart').onclick = restartGame;
            document.getElementById('lc-next').onclick = nextLevel;

        })();
    </script>
</body>

</html>